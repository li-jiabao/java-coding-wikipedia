# MySQL核心内容

![image-20210924160509342](https://gitee.com/Jia_bao_Li/img/raw/master/img/MySQL%E6%9E%B6%E6%9E%84%E5%9B%BE.png)

## MySQL引擎

- MyISAM：5.5之前MySQL使用的引擎
- InnoDB：5.5之后默认使用的SQL引擎

### 二者的异同

- 事务的支持：InnoDB支持事务操作（要么全部成功，要么都失败）
- 崩溃恢复：InnoDB支持崩溃恢复，MyISAM的缺点就是崩溃之后不能恢复数据容易造成数据的丢失
- 外键支持：InnoDB支持
- 行级锁：InnoDB支持
- MVCC多版本并发控制：InnoDB支持
- 效率：正常来说，M有ISAM的效率稍微好一点（适合读密集的情况），但是随着InnoDB的优化和多种功能的支持，InnoDB使用更广泛

## MySQL执行顺序

![](https://gitee.com/Jia_bao_Li/img/raw/master/img/image-20210924172624526.png)

查询语句书写：

```mysql
select distinct *
from table1 as t1
join table 2 as t2
on <on_condition>
where <where_condition>
group by <groupBy_condition>
having <aftergroupby_wher_condition>
order by <orderBy_condition>
limit <limit_condition>
```

优化后的语序(SQL管理层的优化器进行优化后的）：

```mysql
from table1 as t1
on <on_condition>
join table 2 as t2
where <where_condition>
group by <groupBy_condition>
having <aftergroupby_wher_condition>
select distinct *
order by <orderBy_condition>
limit <limit_condition>
```

## 索引

数据库中用来快速查找数据的一种数据结构，这种数据结构维护了一种查找算法，可以快速的查找到你所需数据的所在位置（数据结构维护者数据的引用，可以通过索引定位到数据）

索引本身很大，不可能全部存储在内存中，因此大部分索引存储在磁盘中

- BTree索引：除了单条记录的查询，其他都可以使用Btree索引。使用的是B+索引（范围查找）
- 哈希索引（底层数据结构是哈希表）：单条记录查询比较多的时候，可以使用哈希索引（哈希索引对于范围查找的要求不太好实现）

索引优势：

- 提高数据的检索效率，降低数据库的IO成本
- 通过索引进行排序，降低排序的成本，降低了CPU的消耗

索引缺点：

- 索引是会占用空间的
- 虽然加快了查询的效率，但是会降低表的更新效率（增删改）。更新表数据的时候还需要更新索引信息
- 索引的效率根据设计的好坏会不一样，想要更快需要设计更好的索引规则，针对数据量可以选择合适的索引

需要使用索引的场景：

- 主键自动创建唯一索引
- 频繁作为查询条件的字段应该创建索引
- 查询中与其他表关联的字段，外键关系创建索引
- 查询中统计或者分组的字段
- 查询中排序的字段

不需要使用所用的场景：

- 数据量比较小
- where条件没有使用的字段不建立索引
- 数据经常增删改的字段
- 数据重复且平均分布的表字段，不使用索引，只为经常查询和经常排序的数据理列建立索引
- 数据列包含重复内容过多，建立索引的实际效果并不好

## SQL性能下降的原因

- 等待事件长
- 执行事件长



- SQL语句写的问题（没有使用索引）单值索引：`create index idx_user_name on user(name)`，可对多个字段创建多值索引。
- 索引失效
- 关联太多的join
- 服务器本身的一些问题导致的性能下降

## 事务的特性

- 原子性：事务的操作要么都成功，要么都失败，不存在某一个操作成功其他操作失败
- 一致性：执行读取事务前后，数据保持一致多个事务对数据的读取操作获取的结果都是一致的
- 隔离性：不同事务之间的操作相互隔离不会相互影响
- 持久性：数据库事务的操作一旦提交，对数据的更改是永久的，数据库崩溃都不能改变

## 并发事务下存在的问题

- 脏读：事务A修改某个数据，在修改还未提交的时候，B事务读取数据，此时读取的数据是不正确的，不是修改之后的，用这个数据进行操作结果大概率是会出错的
- 不可重复读：事务A需要对同一个数据进行多次读取，两次读取操作获得的结果不一致，因为可能在两次读取中间，事务B读取数据并进行了修改
- 丢失修改：事务A先对数据进行读取并修改，在A修改提交之前，事务B读取数据也进行修改，B事务修改的结果会将A事务的结果覆盖，导致A的修改丢失
- 幻读：事务A两次读取，第二次读取出现了第一次读取没有出现/少了多条的数据，因为在A的两次读取，事务B向里面插入/删除了多条数据

## MySQL的四种隔离级别

- READ-UNCOMMITTED（读取未提交）：允许读取修改还未提交的数据，会出现脏读、不可重复读、幻读
- READ-COMMITTED（读取已提交）：允许读取修改已提交的数据，会出现幻读、不可重复读，可以解决脏读
- REPEATABLE（可重复读）：对同一字段的读取结果都是一致，除非数据是本身事务修改。不能处理幻读
- SERIALIZABLE（可串行化）：最高的隔离级别，所有的事务依次按照顺序逐个执行。可以解决并发问题

## MySQL的日志

### 1 事务日志

InnoDB事务包含undo log和redo log

undo log：事务开始之前，操作任何数据之前，需要先将需要操作的数据备份到一个地方

作用：

- 回滚数据：程序发生异常错误，根据undo log可以回滚到事务之前的数据状态，保证原子性
- MVCC一致性视图：通过undo log找到对应的数据版本号，保证MVCC视图一致性的必要条件

redo log：事务的执行过程中，开始写入redo log。防止发生故障的时间点，尚有脏页未写入磁盘，重启MySQL服务，根据redo log重做，完成事务未入磁盘数据进行持久化的特性

作用：

- 前滚操作：具备崩溃恢复能力，提供断电重启解决事务丢失数据的问题，保证数据的持久化
- 提高性能：先写redo log记录更新，当有空闲线程时再去执行，redo log满了会进行刷脏，写redo log顺序写，刷脏堆积写，节省了

### 2 BinLog日志

记录数据库表结构的更改（create、alter table）和数据库记录修改操作的更改（insert、delete、update）的日志文件

作用：

- 主从复制使用：主服务器数据库修改就会将binlog的修改同步到从服务器，从服务器会读取日志文件记录进行数据库命令执行同步数据库
- 数据恢复：使用mysqlbinlog工具恢复

### 3 错误日志

存放的是Mysql的错误。记录发生的错误和警告信息，以及SQL启动和关闭的详细信息

### 4 查询日志

记录查询的sql语句，开启会降低myql的整体性能。这个日志文件主要在数据库操作效率低下的时候，需要进行优化时，需要借助这个日志文件来分析到底是哪个语句导致效率低下。（慢查询日志）

## 数据文件

数据文件放在MySQL的data目录下。

frm：数据表结构文件

myd：数据库表数据文件

myi：数据库表索引文件

## 事务的实现原理

MySQL中的事务实现通过redo log和undo log来实现的。

利用undo log当事务操作不成功需要回滚时，根据undo log中的日志记录进行反向语句进行逻辑操作（insert转变为delete）原子性实现

事务的持久性通过redo log来实现，事务提交首先需要将事务的所有日志写入redo log，之后再去执行日志文件中的语句持久化到数据库中（先持久化到redo log）

## 事务隔离的实现

加锁：行级锁、间隙锁、Next-key锁