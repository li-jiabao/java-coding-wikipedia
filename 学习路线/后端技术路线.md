# 技术路线

## 1.分布式

出现分布式的原因：单台服务器压力太大（CPU和内存不足以处理用户的计算请求和访问请求），导致用户访问变慢。

为了解决这类问题，主要有两种解决方案：

- 升级服务器的硬件性能，采用更好的CPU和更大的内存
- 多台服务器集群提升整体处理能力（分布式）

分布式服务器一般将数据库、文件服务器分离出来，使用单独的服务器或多台服务器来部署数据库，这样，每一台服务器需要处理的需求就被减少，响应处理速度更快。

此外，还可以增加缓存来提高数据库读取数据的响应速度（将数据库读取的数据缓存起来，下次访问直接读取数据而不用再访问数据库，速度更快且降低了数据库的压力）。缓存分为本地缓存和分布式缓存，利用多台服务器构成集群提供缓存服务，提升缓存的能力

应用集群部署：将应用服务器也进行集群化的部署

![image-20210923150513018](https://gitee.com/Jia_bao_Li/img/raw/master/img/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2.png)

## 2 缓存

缓存类别：

- 通用缓存：访问数据时先访问通用缓存，缓存中不存在就去访问数据库，将数据库查询的数据存储到缓存中，并返回给请求端，下次再访问就直接从缓存中获取
- 旁路缓存：先去缓存中访问，存在返回，不存在请求自己访问数据源，并将结果写到缓存

缓存优点：

- 降低数据库的访问压力，CDN通读缓存降低服务器的负载
- 如果碰见计算密集型的请求，还可以减少CPU的计算压力，直接返回之前的计算结果即可
- 缓存存储在内存中，比网络中访问或者磁盘中访问速度更快

缓存缺点：

- 缓存数据和数据库数据不一致，会造成数据出错
- 不是所有数据都适合使用缓存存储，一般缓存适合那些被频繁访问的数据
- 缓存设置失效时间，失效就需要重新从数据库读取
- 缓存可能会失效，应该定期清理

## 3 消息队列（异步架构）

同步：等所有操作都做完，才返回结果给用户，这时候的用户程序被阻塞，CPU空闲，造成资源浪费

异步：不用等所有操作完成，先响应请求返回结果告知正在进行后续操作，用户程序不会被阻塞，随后的数据库操作再去慢慢进行（操作完毕之后再告知用户），这个时候用户不被阻塞体验好，可以再去进行其他事件。

使用消息队列实现的异步称为异步架构：生产者将请求发送给消息队列，然后就返回去处理其他的事情，消费者从消息队列取出消息进行响应处理，等到消息处理完毕后通知生产者。如下：用户不需要再等待注册邮件和注册短信发送完毕之后才返回，而是注册信息放入消息队列之后就可以返回，之后就可以进行用户自己的事情

![image-20210923155903678](https://gitee.com/Jia_bao_Li/img/raw/master/img/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%BC%82%E6%AD%A5.png)

消息队列的主要功能：缓存消息，等待消费者消费处理

- 点对点：一个消息被一个消费者消费

![image-20210923155030984](https://gitee.com/Jia_bao_Li/img/raw/master/img/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%82%B9%E5%AF%B9%E7%82%B9%E6%B6%88%E8%B4%B9.png)

- 订阅模式：开发人员在消息队列中设置主题，生产者生产相应的主题发送数据，消费者从对应的主题消费数据，消费者根据自己的业务逻辑分别进行计算

![image-20210923155002826](https://gitee.com/Jia_bao_Li/img/raw/master/img/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.png)

订阅模式可以用用户注册来表示：当用户注册信息发送到消息队列之后，会有存储数据库的消费者、发送验证消息的消费者去进行业务逻辑上的处理，这二者都是注册信息的消费者。

还可以通过用户关注者来解释：当被B站UP主更新视频之后，这个更新消息就会发送到消息队列中，关注这个UP主的用户都可以从消息队列取出该发布消息进行消费，可以观看、点赞等等消费，这些用户就属于消费者。

消息队列优点：

- 降低耦合：调用是同步的话，二者会存在依赖性，一旦需要修改，就需要修改整个，但是异步的话就只需要修改对应某一方的代码即可，降低了消费者和生产者之间的耦合度，业务逻辑修改就更方便，影响范围更小。比如订单系统和库存系统，二者在不使用消息队列的时候订单系统需要调用库存系统接口，二者存在耦合，如果其中一方修改，都需要进行一定业务修改。而使用消息队列，只需要修改特定的业务逻辑
- 快速响应：不需要等待，生产者将消息放入之后就可以继续执行自己的其他业务逻辑，不需要再等待消费者消费之后才能继续执行
- 流量削峰：举例：秒杀业务，传统做法限制用户数量，使用消息队列时，当消息队列的消息长度超过最大长度，就抛弃用户请求或者跳转错误页面。另外一个削峰的例子：用户请求数据库，如果直接让数据请求数据库，并发量大会使数据库压力过大，如果使用消息队列，先将用户请求存储到消息队列，数据库再去慢慢消费请求返回数据，可以减缓数据库的压力
- 消息通讯：消息队列可以实现点对点（两个客户端订阅同一个主题）通讯和聊天室通讯（多个客户端同时订阅同一主题）
- 日志处理：Kafka的应用，解决大量日志传输问题。日志采集客户端类似于生产者，定期采集日志写入消息队列，消息队列接收、存储、转发日志，日志处理应用订阅消息队列消费日志消息

消息队列的缺点：

- 一致性问题：真正的消费者没有正确消费数据，容易造成数据出错导致数据不一致等问题
- 系统可用性降低：需要考虑消息队列是否正常可用
- 系统复杂性提高：需要保证消息不会被重复消费、消息不丢失、消息传递的顺序性问题，这些业务处理就会导致系统复杂性提高

## 4 负载均衡

使用多台机器的时候，需要控制多台服务器的请求数量，不要让某台服务器压力极高而其他服务器空闲。

因此出现了一种分散服务器压力的策略，负载均衡策略

### 4.1 HTTP负载均衡

HTTP请求发送到负载均衡服务器，使用负载均衡算法获取到后端服务器地址返回给用户浏览器，浏览器再进行重定向访问发起请求从而实现负载均衡

### 4.2 DNS负载均衡

DNS通过域名解析获取对应的服务器IP地址，然后去建立HTTP连接访问真正的服务器。不同用户解析会获取到不同的IP地址从而实现负载均衡

### 4.3 反向代理负载均衡（Nginx）

通过反向代理（Nginx等）来进行用户请求的转发：用户请求导入到反向代理，代理查看缓存是否有之前的连接，有直接返回，没有就返回到后台的服务器处理再返回到反向代理缓存

### 4.4 IP负载均衡

负载均衡服务器对数据包中的IP地址进行转换，从而发送到特定的应用服务器

### 4.5 数据链路负载均衡

负载均衡服务器和应用服务器使用相同的虚拟IP，MAC地址不一样，负载均衡服务器通过更改数据包中的mac地址（解决数据量太大导致服务器带宽不足的问题）



## 5 数据存储

数据的高可用

数据主从复制：使用两个数据库存储一样的数据。当应用程序发送更新命令到主服务器的时候，数据库将这条命令同步记录到Binlog（记录所有数据库表结构变更（create、alter table）和表数据修改（insert、update、delete）的二进制日志），其他的线程会从binlog中读取并通过远程通讯的方式将其复制到另外的服务器，服务器收到更新日志之后，就会将其加入到自己的relay log中，然后SQL执行线程从Relay Log中读取并在本地运行一遍，从而实现主从数据库的同步

主从复制一般用来进行数据库的读写分离方便，可以使用<font color='red'>一主多从的方式保证高可用</font>



![image-20210923190304809](https://gitee.com/Jia_bao_Li/img/raw/master/img/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png)

改善存储

数据库分片：将一张表分成若干篇，每一片都包含一部分的行记录，每一片存储在不同的服务器中

最初的分片方式：通过ID的奇偶区分放在不同的服务器（需要增加服务器时，需要改动代码）

余数哈希算法：根据主键ID和服务器的数量取模，确定服务器的位置。

## 6 搜索引擎

互联网中的网页位置？

URL存放在池子中，池子中取出URL模拟请求，下载对应的HTML，并存放在服务器中，解析HTML中的URL并将未爬取过的存放到池子或者队列中继续再去爬取。

然后再根据爬取的网页编号得到网页集合，通过分词技术获取单词，并根据单词和网页ID得到对应的矩阵关系

![image-20210923193514803](https://gitee.com/Jia_bao_Li/img/raw/master/img/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95.png)

## 7 微服务

为什么使用微服务？不希望一个系统中，某个功能的改变会影响到整个系统的其他部分，希望各个功能模块拆分清晰，每个模块之间不会相互影响（降低模块之间的耦合性）

单体架构的缺点：

- 代码分支管理麻烦
- 新增功能麻烦

微服务：

- 大应用拆分为多个小模块
- 小模块不属于集群
- 远程调用的方式依赖各个独立的模块完成业务的处理

分解出来的小模块就是微服务，这些模块组合起来就是微服务架构。

拆分程多个微服务之后，如何调用这些服务？通过微服务架构的注册中心，调用模块提供的接口即可：

![image-20210923171023533](https://gitee.com/Jia_bao_Li/img/raw/master/img/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png)

## 8 高可用

一个服务器挂掉不会影响整个系统的工作，其他的机器仍可照常工作。

系统挂掉原因：

- 硬件故障
- 数据库宕机
- 磁盘损坏
- 应用程序bug
- 网络问题

### 高可用策略

- 冗余备份：任何一个服务器都有备份，一旦一个挂掉，可以立即进行切换恢复正常
- 负载均衡：多台服务器分担压力，保证服务器不会因为过压挂掉，同时还会检测服务器的状态，服务器不正常时可以将请求换到其他正常的服务器即可
- 限流：对部分请求进行丢弃处理，保证大部分用户正常请求完成任务
- 降级：屏蔽当前看来不是很有用的任务。比如秒杀活动，确认收获功能给与的压力过大，在秒杀活动期间，并不是核心任务，可以暂时关闭，将资源留给秒杀活动，增加此时的系统可用性
- 异地多活：各个地方部署数据中心，异地多活的多机房策略，用户可以访问任何数据中心，通过域名解析找到对应的数据中心机房即可，这样就算一个地方的数据中心挂掉，其他的还能保证整个业务功能的正常

## 9 高并发

高并发的三种解决方案：

1. 系统拆分：将一个系统拆分为多个子系统，每个子系统关联一个数据库，Dubbo来操作，降低了原来一个数据库的压力，将压力均摊到多个数据库，并发量也会因此降低
2. 缓存：针对读多写少的场景，可以使用缓存，让高并发的压力转换到缓存中而不是去访问数据库。
3. 消息队列：针对高并发写的场景，可以将大量的写操作存入消息队列，然后数据库再去慢慢消费写操作，可以减少数据库的压力，同时也能完成并发的请求

此外数据库针对高并发的解决：

- 分库分表：将数据库拆分为多个库，对抗更高的并发，将一个表拆分为多表，保持表数据量小，提高sql的性能
- 读写分离：大部分数据库读多写少，可以对数据库做一个主从架构，主库写入，从库读取，读写分离，此外读流量太多，还可以做多个从库
- solrCloud：分布式搜索方案

## 10 高性能



## 11 安全性



## 12 大数据







参考：

[参考文章：绯闻女友问我：「后端技术学些啥」]([绯闻女友问我：「后端技术学些啥」 (qq.com)](https://mp.weixin.qq.com/s/co6ZiALBCUHxc-8SpcKxPw))

