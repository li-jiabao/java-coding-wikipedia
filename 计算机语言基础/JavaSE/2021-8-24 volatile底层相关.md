# Java的volatile底层知识

## 主存、缓存

主存：一种可以直接和CPU交换信息的存储器，主存存放程序的代码、数据等信息。

缓存：介于主存和CPU中间的一种高速缓存器，用来解决CPU读取速度和主存的读取速度严重不匹配的问题

缓存一般分为三级缓存：L1、L2、L3

- L1高速缓存：也叫一级缓存。一般内置在内核旁边，是与CPU结合最为紧密的CPU缓存。一次访问只需要2~4个时钟周期
- L2高速缓存：也叫二级缓存。空间比L1缓存大，速度比L1缓存略慢。一次访问约需要10多个时钟周期
- L3高速缓存：也叫三级缓存。部分单CPU多核心的才会有的缓存，介于多核和内存之间。存储空间已达Mb级别，一次访问约需要数十个时钟周期。

当CPU要读取一个数据时，首先从L1缓存查找，命中则返回；若未命中，再从L2缓存中查找，如果还没有则从L3缓存查找（如果有L3缓存的话）。如果还是没有，则从内存中查找，并将读取到的数据逐级放入缓存。

## 总线锁和缓存锁

总线锁：锁住总线（总线是连接CPU、主存和其他I/O设备的线路）。通过处理器发出lock指令，总线接收到lock指令之后，其他处理器的请求就会被阻塞，知道处理器执行完成。锁住总线后，该处理器就可以独占内存使用

## 缓存一致性





## 并发编程的三大特性

### 原子性

一个操作或者多个操作，要么 都执行成功，要么都执行失败，也就是在某个操作或者某些操作的过程不会被中断

### 有序性

保证代码按照先后顺序执行（由于JMM模型允许编译器和处理器优化效率，可以进行一定的指令重排，除了happens_befores八个原则中的不可以重排，其他都是允许重排的）

#### cpu指令乱序

指令乱序：为了cpu的性能和效率考虑，对于某些操作指令的顺序，可以不严格按照顺序执行，可以将某些指令提前执行，借此提前完成任务，提高cpu的利用效率

### 可见性

多个线程同时访问某个变量时，一旦某个变量发生更改，其他线程立即可以看到修改后的值

#### JMM（Java内存模型）

JVM规范红定义的一种模型，用来屏蔽掉各种硬件和操作系统的内存访问差异，使Java程序在各种平台下都可以达到一致的并发效果。

**JMM的目标**：定义程序中各个变量的访问规则（变量存储到内存和从内存取出变量的细节）

### JMM内存细节实现

1. 有变量都存储在主内存中，每条线程都有自己的工作内存，线程的工作内存用来从主内存拷贝副本。
2. 线程对于变量的读写必须在工作内存中进行，不能直接读写主内存的变量
3. 线程工作内存之间不能相互访问，只能主内存来读取工作内存的变量

![image-20210823235824576](https://i.loli.net/2021/08/23/Vy9mHfZpx3IPJTv.png)

### volatile可见性的实现

- 某个线程发生了变量的修改后，jmm强制把该线程的工作内存中的最新变量更新到主内存中
- 写操作会导致其他线程的工作缓存失效（工作内存失效），会重新再从主内存中读取

其实底层就是**缓存一致性**的一种实现机制

## 内存屏障

是一种用于同步的屏障指令，是CPU或者编译器用在对内存随机访问的操作中的同步点，在该同步点之前的所有读写操作执行完之后，才回去执行内存屏障之后的内容

#### 硬件层级的内存屏障

- sfence：写屏障（store barrier），在写指令之后插入写屏障，可以让写入缓存中的最新变量数据写回到主存中，保证写入的数据对其他线程可见
- lfence：读屏障（load barrier），在读指令之前插入读屏障，可以让缓存中的数据失效，强制缓存重新从主存中加载数组，保证读到的数据是最新的数据
- mfence，全能屏障（mix/modify barrier），兼具读写屏障的共呢个
- lock，不是内存屏障，而是一种锁，执行时会锁住总线保证执行顺序，甚至跨越CPU

#### JMM层面的内存屏障

- LoadLoad：在屏障后的读取操作执行前，保证屏障前的数据读取完毕
- StoreStore：在屏障后的写入操作之前，保证屏障之前的写操作对其他处理器和线程可见
- LoadStore：保证屏障后续写入操作执行前，屏障前的读取数据执行完毕
- StoreLoad：保证屏障后续读操作执行前，屏障前的写入对所有的处理器和线程可见

```java
// jvm在volatile变量的读写前后均会加上内存屏障，一定程度保证有序性，同时保证了可见性

LoadLoadBarrier
读操作
LoadStoreBarrier

SotreStoreBarrier
写操作
StoreLoadbarrier
```

## volatile的有序性和可见性实现

### 可见性实现

通过添加读写屏障实现：

- 保证每次更新变量更新之后，强制刷新到主存
- 对于读操作执行前，强制都从主存中重新读取数据

### 有序性实现

利用了底层的lock指令：`lock addl $0,0,(%%rsp)`

代码`lock; addl $0,0(%%rsp)` 其中的`addl $0,0(%%rsp) `是把寄存器的值加0，相当于一个空操作（之所以用它，不用空操作专用指令nop，是因为lock前缀不允许配合nop指令使用）

#### lock

**lock前缀，会保证某个处理器对共享内存（一般是缓存行cacheline，这里记住缓存行概念，后续重点介绍）的独占使用。它将本处理器缓存写入内存，该写入操作会引起其他处理器或内核对应的缓存失效。通过独占内存、使其他处理器缓存失效，达到了“指令重排序无法越过内存屏障”的作用**

#### 缓存行

缓存行就是缓存从主存中读取数据的大小，64位电脑位64字节，这个是长期的实践得出的。

