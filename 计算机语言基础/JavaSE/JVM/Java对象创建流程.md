# 对象创建流程

1. new指令：判断类是否已经加载进来，查看常量池中是否包含该类的符号引用，有就进入下一步，没有就执行类加载、验证、准备、解析流程将类加载到常量池符号引用
2. 分配内存：为需要创建的对象分配一块内存，内存大小在类加载完毕之后就是确定了的，因此内存分配就是按照类加载后的类信息获取到的
3. 初始化零值：为对象赋值初始化零值（不包含对象头），字段的数据类型赋值相应的零值
4. 对象的初始化设置：这部分主要是设置Java对象头的信息，如hashCode值，GC分代信息，类指针Kclass，以及锁信息等
5. init：按照程序员在类创建时的设定初始化，将字段赋值（构造函数调用执行）

# 类加载过程

1. class文件加载：使用类加载器从字节码文件中加载类的信息，内存中为该类生成一个对象（该类的Class对象）在方法区中创建这个类的入口（存储方法区）
2. 验证：验证字节码文件中的信息是否符合虚拟机规范
3. 准备：为类变量（静态变量）分配内存并设置初始值
4. 解析：将符号引用转换为直接引用（得到类、字段、方法在内存中的指针或者偏移量）
5. 初始化：init方法执行，执行类构造器的过程

不一定是按照顺序执行，可能几个步骤穿插着执行

# 双亲委派机制

指类加载过程中，首先从父类加载器去找是否可以找到，找不到了再交由子类加载器去加载，如果到子类加载器（自定义加载器）还找不到，就会报异常`ClassNotFoundException`

![image-20210829232433351](https://i.loli.net/2021/08/29/jo1eBiWyAaQuNgU.png)

### 1.2为什么采用双亲委派机制？

处于安全考虑，如果用户写了和Java类库里面同名的包，如果不采用双亲委派机制，可以随意加载类，就会出现Java类库被覆盖的风险，这样就会影响程序的稳定性和安全性，此外如果外界有人利用不是双亲委派机制的这个漏洞，可以攻击java程序，给用户带来很大的风险。

除了安全的优点之外，双亲委派机制可以保证不同的类加载器加载最后得到的类都是同一个Class对象

### 1.3懒加载（lazyloading）

JVM的加载是一种懒加载的机制，只有该类需要使用时才将其加载到内存，节省内存

下面是一些需要初始化和不需要初始化的一些情况

需要

- 初始化子类，父类首先初始化
- 静态成员和静态语句块首先初始化
- 虚拟机启动时，被执行的主类必须初始化

不需要：

- final变量并不初始化
- 子类引用父类的静态字段，子类不需要执行初始化
- 定义对象数组，不需要加载数组对象类
- 利用反射机制加载类时不会触发初始化
- ClassLoader的loadClass方法不执行初始化

### 1.4 ClassLoader源码

怎么实现类加载过程：

1. 首先findInCache方法查找缓存
2. 然后进入到父类，执行parent.loadClass()，先调用父类的类加载器
3. findClass调用查找类方法

### 1.5自定义类加载器

1. extends ClassLoader继承类加载器
2. 重写加载器类中的findClass方法实现类查找，在这里面需要使用defineClass方法
3. 可以对加载的类进行加密

### 1.6JVM编译器和解释器

Java实际上可以看成是一种混合模式的编译解释语言

混合模式：

- 对于语言中的热点代码，使用JIT进行编译到本地，可以加快运行速度，使用XX:CompileThreshold=10000指定热点代码检测的阈值
- JVM默认采用混合模式：设置Xmixed

热点代码：

- 多次重复调用的方法或者循环语句