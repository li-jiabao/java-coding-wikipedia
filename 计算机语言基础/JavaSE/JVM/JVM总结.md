# JVM知识汇总

![image-20210915234634676](https://gitee.com/Jia_bao_Li/img/raw/master/img/JVM%E7%BB%93%E6%9E%84.png)

![](https://cdn.jsdelivr.net/gh/li-jiabao/NoteImg@main/img/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA.png)

```java
java -help   // 查看所有标准参数
java -X    // 查看所有非标准参数
java -X:+PrintFlagsFinal          // 查看所有调优参数
java -XX:+PrintFlagsInitial
```

## 1 JVM内存管理

除了程序计数器不会报**OutOfMemoryError**异常，其他的内存区域当内存不够时会报内存溢出错误

栈内存当超过规定栈深度的时候会报**StackOverflowError**异常

### 1.1 运行时内存区域

#### 1.1.1 程序计数器

**<font color='red'>线程私有内存区域</font>**

存放的内容：

- 线程执行的字节码的行号指示器

字节码解释器通过程序计数器的值来读取下一条需要执行的字节码指令（程序控制执行）

#### 1.1.2 虚拟机栈

**<font color='red'>线程私有内存区域</font>**

存放的内容：

- 方法
- 局部变量表（对象引用，基础数据类型）、操作数栈、动态连接、方法出口等方法相关的信息

#### 1.1.3 本地方法栈

**<font color='red'>线程私有内存区域</font>**

存放的内容：

- Java虚拟机中的本地方法的内存区域

#### 1.1.4 堆(GC堆)

**<font color='red'>线程共享内存区域</font>**

存放的内容：

- 对象实例

为了方便内存管理和垃圾回收，将堆内存按照对象的年龄进行了分代（不同年代垃圾回收方法不一样）：

- 新生代：对象年龄小于15（默认）所在的内存区域，新生代又分为Eden、from survivor、to survivor三个，8:1:1的比例分配。
- 老年代：存放存活了15次垃圾回收的对象

分代并不是强制性的。对于垃圾回收也有不采用分代机制来进行的。

<font color='red'>分代是为了更好的回收内存、更快的分配内存</font>

#### 1.1.5 方法区(永久代->元空间)

**<font color='red'>线程共享内存区域</font>**

存放的内容：

- 常量
- 静态变量
- 虚拟机加载的类型信息
- JIT编译后的代码缓存数据

在jdk1.7之前，运行时常量池、静态变量、字符串常量池都是位于方法区（hotspot为了方便管理定义为了永久代）

之后，将字符串常量池和静态变量移出方法区放置到java堆中，运行时常量池仍然放在方法区中，只是此时的方法区不再是采用堆内内存，而是使用直接内存（直接使用native函数库分配堆外的物理内存，使用堆中DirectByteBuffer作为内存引用操作内存），这个时候的方法区也被称为元空间

#### 1.1.6 运行时常量池

存放内容：

- 字面量
- 符号引用
- 直接引用

### 1.2 Java对象

Java对象创建、对象布局、对象访问过程

#### 1.2.1 对象创建过程

当Java遇见new的对象创建步骤时，需要经历的过程

1. 检查过程：检查对象是否可以在常量池中定位到对应类的符号引用，如果找不到该类引用，报ClassNotFound异常，有则检查类是否已经被加载、解析、初始化过，没有则需要执行相应的类加载过程。如下图0行字节码new，执行对象创建，定位类信息
2. 分配内存：从堆内存中找出一块内存分配给该对象实例（**对象所需内存在类加载完成之后便可完全确定**）3，dup分配堆内存给对象实例
3. 初始化零值：将字段和变量等赋初值（基本数据类型赋值0、false这一类，String就赋值""等）
4. 对象头设置：类型指针（指向类的类型）、对象的hashCode、GC分代信息、锁类型信息等等
5. 构造函数执行：按照程序员对于对象的设置进行相应的对象配置（赋予字段真正的值）4：invokespecial执行构造函数设置程序员想要的配置内容

![image-20211007190835939](https://gitee.com/Jia_bao_Li/img/raw/master/img/Java%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E5%AD%97%E8%8A%82%E7%A0%81.png)

**Java对象内存分配方式**：

- 指针碰撞：将指向空闲空间的指针向空闲空间位置移动对象大小相等的距离（对于内存规整的连续内存分配，采用这一种分配方式）一般对于那些使用标记整理算法的垃圾回收器回收的内存使用这一方式分配（Serial和ParNew垃圾回收器）
- 空闲列表：对于不连续的内存空间，需要找到合适大小的一块内存并将其分配给对象实例，这一类方法需要维护一个列表记录空闲的内存区域，找到一块足够大的内存分配（对于使用标记清除算法的回收器，一般用这个方法分配内存，如CMS）

**如何保证对象创建过程中的线程安全**：

- CAS：利用底层的CAS机制，采用失败重试的方式保证线程安全
- TLAB：内存分配按照线程划分在不同空间进行（每个线程在Java堆中预先分配一部分内存，称之为线程本地分配缓存TLAB，只有当线程本地缓冲区内存用完了，分配新的内存才需要同步锁定。是否使用TLAB机制，需要使用`-XX: +/-UseTLAB`参数进行配置

#### 1.2.2 对象布局

![image-20211007200941194](https://gitee.com/Jia_bao_Li/img/raw/master/img/Java%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80.png)

组成：

- 对象头：MarkWord和类型指针
  - MarkWord ： hashCode信息、锁信息、分代信息、GC垃圾回收信息，64位的markword具体内容见下图
  - 类型指针：指向类型元数据的指针，确定对象属于哪个类的实例
- 实例数据：对象实例的各类型字段内容、父类中字段等
- 对齐填充：用来保证内存大小为8的整数倍而填充的数据

![image-20210913235949432](https://gitee.com/Jia_bao_Li/img/raw/master/img/Java%E5%AF%B9%E8%B1%A1%E5%A4%B4markword.png)

#### 1.2.3 对象访问定位

**怎么从栈中的reference找到对应的对象地址？**

句柄访问：Java堆中需要划分出一块内存来作为句柄池，栈中引用reference存储的就是对象的句柄地址，句柄包含了对象实例数据和类型数据具体的地址信息

直接指针：Java堆中对象内存布局必须考虑如何放置访问类型数据的相关信息，reference存储的就是对象地址。访问对象只需要一次内存访问，开销相对较小

**优劣对比**：

- 句柄访问好处是对象移动时只会改变句柄中的实例数据指针，reference不需要修改
- 直接指针好处是访问速度更快，节省了一次内存访问开销，对象访问比较频繁，这一改善带来的效率很客观

### 1.3 内存溢出异常

- 堆内存溢出：通过设置非标准参数:`-Xms128k  初始堆大小`。`-Xmx10m  最大堆大小`
- 栈溢出：设置栈大小：`-Xss256k  设置栈内存大小`
- 直接内存内存溢出：`-XX:MaxDirectMemorySize=10m   设置最大直接内存`
- 元空间内存溢出：`-XX:MaxMetaspaceSize=10m   设置最大元空间大小`

## 2 垃圾回收和内存分配

### 2.1 判断对象死亡的方法？

#### 2.1.1 引用计数法

每当有一个地方引用该对象，计数器加1，引用失效就减1，当计数器为0说明对象不可达

- 循环引用问题：

  ```java
  public void cyclicReference() {
      Object a = new Object();
      Object b = new Object();
      a.instance = b;
      b.instance = a;
  }
  // 实际上a，b已经没有其他引用，且这两个对象都不会被再访问
  // 但是因为两者之间相互引用，引用计数器不会为0，这两个对象都不会被删除
  ```

#### 2.1.2 可达性分析（GC root法）

通过一系列的GC root根节点，从这些节点开始，向下搜索。如果某些对象和GC root之间不能通过root访问到，则说明这个对象不再被使用了

可作为根节点的对象：

- 虚拟机栈中引用的对象
- 方法区静态属性引用的对象
- 方法区常量引用的对象
- 本地方法栈引用的对象
- 虚拟机内部的引用对象（基本数据类型的Class对象、系统类加载器等）
- 被同步锁持有的对象

进行可达性分析的时候需要<font color='red'>暂停用户线程，需要停止对象引用关系的变化</font>，不然很难确保分析结果的正确性

下面将介绍集中虚拟机实现中为了保证回收的正确性所作的一些操作和理论

##### 2.1.2.1 ==安全点==

<font color='red'>生成了OopMap的指令位置处</font>，因为这个位置的OopMap记录了该处存在一个对象的引用，以及该对象的地址和偏移量.

JVM中强制要求只有到达了安全点后才能够暂停去进行垃圾回收。

安全点的选择不能过少导致垃圾回收器等待时间过长，同时也不能设置的过多导致频繁垃圾回收增加内存负荷。

安全点一般处于某些特定功能的指令位置：

- 方法调用
- 循环跳转
- 异常跳转

##### 2.1.2.2 ==如何保证线程都执行到安全点==

**抢先式中断**：垃圾回收时，先暂停所有线程，如果发现某个线程中断处不处于安全点，恢复执行直到跑到安全点

**主动式中断**：垃圾收集需要中断线程时，不直接操作线程，而是设置一个标志位，让每个线程不断轮询这个标志位，如果该标志位为真，就主动在最近的安全点中断挂起。标志位和安全点重合的，此外标志位位置还有创建对象和在Java堆中分配内存的地方

##### 2.1.2.3 安全区域

安全点是用来处理线程在运行时保证垃圾回收时的正确性的，对于线程没有处于运行时的情况，不能响应虚拟机的请求，JVM不能一直等待线程恢复执行，因此衍生了安全区域。

**安全区域**：<font color='red'>在某个代码片段之中，引用关系不会发生变化，这个代码片段就是安全区域</font>，因此在这个区域任何位置进行垃圾回收都是安全可靠的。

线程执行到安全区域时会先标记自己已经进入安全区域，当需要垃圾回收时，可以直接忽略这些进入了安全区域的线程，执行垃圾回收，当这些线程想要离开安全区域时，需要先判断虚拟机是否完成了根节点枚举，如果完成了可以继续执行，如果没有完成，会一直等待阻塞直到可以离开安全区域

##### 2.1.2.4 记忆集

**记忆集**：记录非垃圾回收区域指向收集区域的指针集合的一种抽象数据结构

记忆集的记录精度：

- 字长精度：记录精确到一个机器字长（寻址位数：32位或者64位），该字包含跨代指针
- 对象精度：记录精确到一个对象，该对象字段包含跨代指针
- 卡精度：记录精确到一块内存区域

**卡表**：精度为卡精度的记忆集实现，这一类数据结构称之为卡表

**Hotspot的卡表实现：**

使用字节数组来实现，一个数组元素标识了内存中的一块指定大小的内存区域，该大小在Hotspot是2的九次幂（512字节），内存地址在字节数组中寻址的方法`CARD_TABLE[this address >> 9]`，为0表示没有其他内存区域的指针，1表示该区域内有对象包含跨区域的指针（为1表示脏页记录）。因此垃圾回收的时候只需要判断内存地址所在的字节数组元素是否为1，借此判断是否存在跨区域的对象指针，存在就将这块区域加入GC root来进行扫描

##### 2.1.2.5 并发的可达性分析

三色标记：记录对象是否被垃圾回收器访问过

- 白色：没有被访问过
- 黑色：对象被访问过，且该对象所有引用都已经扫描
- 灰色：对象被访问过，但是还有引用没有被扫描过

并发存在的两类问题：

- 原本死亡的对象重新标记为存活，可以忍受，因为只是内存少回收了一些
- 原本存活对象被标记为死亡，<font color='red'>致命错误，会导致程序出错</font>

出现对象消失的条件：

- 赋值器插入了一条黑色对象到白色对象的新引用（死亡对象存活）
- 赋值器删除了一条灰色对象到该白色对象的引用或者间接引用（存活对象死亡）

并发问题的解决方案：

- ==**增量更新**==：当黑色对象插入新的指向白色对象的引用时，就将这个新插入的引用记录下来，等并发扫描过后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次
- ==**原始快照**==：灰色对象要删除指向白色对象的引用关系时，将这个要删除的引用记录下来，并发扫描结束之后，再将这些及路过的引用关系中的灰色对象为根，重新扫描一次。引用关系删除与否都会按照初始快照再次扫描搜索。

#### 2.1.3 强、软、弱、虚引用

==强引用==：指的是像new对象赋值的这一类`Object o = new Object()`。强引用存在，对象就永远不会被回收

==软引用==：指的是在内存足够的时候不会被回收的对象，但是当内存不够时，软引用的对象可能会被回收。非必须的对象。使用`SoftReference`类来实现软引用

==弱引用==：指那些非必须的对象，这一类对象只能活到垃圾回收的时候，垃圾回收开始这一类对象一定会被回收,使用`WeakReference`类来实现弱引用

==虚引用==：对象是否有虚引用不会影响对象是否会被垃圾回收，虚引用也不能用来获取对象实例。这个引用是<font color='red'>用来在引用对象被回收时可以收到一个系统通知</font>。`PhantomReference`类实现虚引用

#### 2.1.4 常量和类死亡的判断

类判定死亡需要满足三个条件：`-Xnoclassgc参数用来控制是否对类进行回收`,`-XX:+TraceClass-Loading和-XX:+TraceClassUnLoading查看类加载和卸载信息`

- 类所有的实例都被回收
- 加载该类的类加载器被回收了
- 在任何地方该类的Class对象没有被引用，无法通过反射访问该类的方法

常量死亡：

- 没有任何引用指向该常量

### 2.2 分代理论

分代理论的三个假说：

- 1：绝大多数对象朝生夕死
- 2：熬过多次垃圾回收的对象越不容易被回收
- 3：跨代引用对于同代引用只占据极少数

分代收集：

- 新生代收集（Minor GC）：目标是新生代的垃圾回收
- 老年代收集（Major GC）：目标是老年代的垃圾回收
- 混合收集（Mixed GC）：目标是全部的新生代和部分老年代垃圾回收
- 整堆收集（Full GC）：目标是整个Java堆和方法区（老年代和新生代）垃圾回收

### 2.3 内存分配策略

#### 2.3.1 对象优先在Eden分配

大多数情况下，对象在新生代的Eden区中分配，当Eden区没有足够的空间进行分配时，会进行一次MinorGC新生代的垃圾回收。

#### 2.3.2 大对象直接进入老年代

指定大对象的临界值：`-XX:PretenureSizeThreshold`超过这个值的对象就直接分配在老年代中，用来避免大对象在新生代的内存复制开销

大对象：指那些需要大量连续内存空间的Java对象，很长的字符串，或者元素数量庞大的数组。大对象的复制开销

#### 2.3.3 长期存活的对象进入老年代

根据对象的年龄来判断是否在新生代还是老年代，默认当对象年龄大于15的时候，对象就会被放到老年代内存中

对象每活过一次MinorGC任然存活，该对象的年龄就加1。

对象从新生代变为老年代的年龄阈值设置通过参数：`-XX:MaxTenuringThreshold`设置对应的年龄，默认15

#### 2.3.4 动态对象年龄判断

Hotspot虚拟机不总是要求对象年龄必须达到设定的年龄才能晋升。

如果某个年龄对象的大小总和大于Survivor的一半，所有大于等于该年龄的对象可以直接进入老年代，需要等到达设定的阈值。

#### 2.3.5 空间分配担保

发生MinorGC之前，虚拟机需要先检查老年代最大可用的连续空间是否大于新生代的所有对象的空间，如果成立，这一次MinorGC可以确保安全，如果不成立，则先查看`-XX:HandlePromotionFailure`参数是否设置为担保失败，如果设置了允许，会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，大于的话会尝试进行一次MinorGC，但是这次GC有风险，可能老年代的连续空间不足以承担新生代对象晋升的空间。如果小于或者没有设置为云粗担保，会改为进行一次FullGC全堆GC。

### 2.4 垃圾回收算法

**垃圾回收算法效率相关的一些概念：**

- 串行：垃圾回收时，其他线程都暂停
- 吞吐量：整个垃圾回收过程中STW的单位时间最短
- 响应时间：垃圾回收过程中STW时间最短

#### 2.4.1 标记-清除算法

首先标记所有需要回收的对象，然后标记完成之后，统一进行对象的内存回收，或者标记所有存活对象，再回收未标记的对象。**最基础的回收算法**

缺点:

- 内存碎片话比较严重
- 对于大对象可能存在没有足够的连续内存分配的情况，还需要再进行一次垃圾回收

#### 2.4.2 标记-复制算法

大多数回收器用来回收新生代的内存，因为新生代内存的死亡率很高，因此存活的对象少，所需要复制的内存较小。

**因此出现了  Eden:From:To  =  8:1:1  的内存分配，新生代中**

首先标记，然后将存活对象复制到另外一块内存上，复制完成后清理之前的整块内存

缺点：

- 将整块内存分成了两块，导致单块可用内存量减小
- 空间浪费较多
- 存在STW现象，因为复制需要更新对象引用

#### 2.4.3 标记-整理算法

先标记回收对象，然后将对象往内存的某一侧移动，这样在另外一块内存中就都是空闲可用的内存

缺点：

- 移动存活对象需要更新对象引用的地址，对于老年代存活对象多的区域，更新所需代价高
- 而且对象引用更新操作需要暂停用户程序
- 存在Stop The World的停顿（暂停用户程序来执行垃圾回收）

### 2.5 垃圾回收器

下图中的连线表示两者可以搭配在一起使用进行垃圾回收

下面的垃圾回收除了CMS和G1，在整个垃圾回收过程中所有的用户线程都是暂停的，为了确保垃圾回收过程中的正确性。

CMS在并发标记和并发清除是并发的不暂停用户线程，在初始标记和重新标记都是需要暂停用户线程的

G1在并发标记的时候是不暂停用户线程的，在初始标记和重新标记需要短暂的暂停用户线程，筛选回收的时候也需要短暂的暂停，不过这个暂停时间可以交由用户选择，暂停时间短时就回收少量的但是收益高的内存区域，长就回收多一些的内存区域

![image-20211010145552656](https://gitee.com/Jia_bao_Li/img/raw/master/img/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png)

==衡量垃圾回收器效率的几个指标==：

- 内存占用（Memory Footprint）：垃圾回收程序执行过程中的内存使用量
- 吞吐量：用户程序执行时间/(垃圾回收占用时间+用户程序时间)
- 延迟：垃圾回收过程中，用户程序停顿的时间。

#### 2.5.1 Serial垃圾收集器

JDK最早出现的单线程的垃圾收集器，目前用于客户端模式下的默认新生代垃圾回收器，==基于标记-复制算法==

优点：

- 简单高效，内存占用（Memory footprint）最小
- 单线程下的垃圾回收效率最高
- 适合轻量级的管理的内存较少的应用（用户桌面级应用和部分微服务应用比较适合）因为停顿的时间的很短，只要垃圾回收不频繁还是可以接受的

缺点：

- 具有较长的STW
- 单线程的，相较其他垃圾收集器的效率较低

#### 2.5.2 ParNew垃圾收集器

Serial垃圾收集器的多线程并行版本，可以同时使用多条线程进行垃圾收集，其他的参数、收集算法等等都和Serial一致。可以和CMS垃圾回收器搭配使用，基于==标记-复制算法==

优点：

- 使用了多线程，在多线程环境下的垃圾回收效率相对好一些
- 多核心处理器的环境，效率很不错，在服务器这类处理核心多的环境比较适用

缺点：

- 单核心处理器环境，由于存在线程切换开销，效率可能还比不上Serial

#### 2.5.3 Parallel Scavenge垃圾回收器

JVM参数：`最大垃圾回收停顿时间：-XX:MaxGCPauseMillis、吞吐量大小设置：-XX:GCTimeRatio`

为了提高系统的吞吐量，吞吐量就是处理用户线程和整个线程环境下的工作时间比值；为了提高吞吐量，需要减少垃圾回收占用的时间。基于==标记-复制算法==

因此这款回收器的主要目的就是提高吞吐量让其达到可控制的吞吐量

优点：

- 内部有一个自适应策略，JVM自己根据运行时的状态动态调整，只需要设置上面提到的两个参数设置相应的目标值即可
- 吞吐量优先的垃圾回收器，适合后台运算多不需要交互的场景

缺点：

- 垃圾收集时间和吞吐量之间存在一定的冲突，减短垃圾回收器可能导致吞吐量下降
- 对于交互比较多的场景不太适用

#### 2.5.4 Serial Old垃圾收集器

Serial垃圾回收器的老年代版本，单线程的，使用==标记-整理算法==

使用一般和Parallel Scavenge收集器搭配使用，或者当CMS失败后的后备方案。客户端模式下的垃圾回收器

#### 2.5.5 Parallel Old收集器

Parallel Scavenge的老年代版本，支持多线程并发是偶系，基于==标记-整理算法==

注重吞吐量的垃圾收集器

优点：

- 适用于吞吐量优先的场景
- 适用于处理器资源稀缺的场景

缺点：

- 停顿时间和吞吐量的冲突

#### 2.5.6 CMS垃圾收集器

![image-20211010154440282](https://gitee.com/Jia_bao_Li/img/raw/master/img/CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B.png)

JVM参数：

- CMS触发百分比：老年代使用了多少空间后激活`-XX:CMSInitiatingOccupancyFraction`，提高这个参数值可以降低内存回收频率
- 上面参数设置过高容易导致预留的内存不能满足分配新对象的需要，触发一次==并发失败==，需要进行Serial Old预案执行

以<font color='red'>最短回收停顿时间为目标</font>的垃圾收集器。是一款可靠的并发垃圾回收的垃圾回收器，使用==标记-清除算法==

步骤：

1. 初始标记：需要STW保证并发安全，仅仅标记一下GC root直接关联到的对象，速度很快
2. 并发标记：可以多线程交互工作，遍历整个对象图的过程
3. 重新标记：需要STW保证并发安全：修正并发标记过程中出现并发错误的那一部分对象，增量更新的步骤在[并发的可达性分析](#####2.1.2.5 并发的可达性分析)一节中介绍过了
4. 并发清除：可以多线程交互。因为不需要移动存活对象

优点:

- 适合B/S系统的服务端或者互联网网站这一类强交互的场景
- 更关注服务的响应时间，让垃圾回收停顿时间尽可能短
- 并发标记清除，停顿低

缺点：

- 处理器资源敏感，由于占用一部分线程，导致应用程序变量，总吞吐量降低
- 无法处理浮动垃圾（当此垃圾回收过程中用户线程新产生的垃圾，由于并发标记结束后才产生的，因此不会被标记为这次需要回收的垃圾），这一类垃圾只能留到下一次垃圾回收过程进行回收
- 标记-清除算法实现，会产生空间碎片

#### 2.5.7 Garbage First垃圾回收器

JVM参数：

- region的大小：`-XX:G1HeapRegionSize`设置内存区域分区的大小，对于大对象，可以存放在连续的N个region中

JDK9之后，服务端模式下的默认垃圾回收器，CMS则是不推荐使用的垃圾收集器。

停顿时间模型：目标是能够支持指定一个长度为M毫秒的时间片段中，垃圾回收的时间大概率不超过N毫秒。

G1跳出了分代垃圾回收，面向的是堆内任何内存区域的垃圾回收。垃圾回收的标准变为了：哪块内存中存放的垃圾数量最多、回收的收益最大（Mixed GC模式）

G1的核心：基于region的堆内存布局，将内存区域划分为多个大小相等的独立区域，每一块区域都可以根据需要作为新生代的空间或者老年代的空间。大对象一般用好几个region存放，一般将大对象的内存区域作为老年代看。然后基于每一个region的回收收益建立一个优先级列表，优先回收那些收益最大的region。

基于region和回收收益的优先级列表，使得G1的在指定时间内的回收效率尽可能高，因此也就可以实现低停顿时间。

![image-20211010162721949](https://gitee.com/Jia_bao_Li/img/raw/master/img/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B.png)

**<font color='red'>G1回收过程</font>**：前三个过程和CMS类似，1、3阶段需要短暂停顿用户线程

1. 初始标记：标记一下GC root直接关联的对象，需要短暂暂停用户线程
2. 并发标记：根据GC root进行并发的可达性分析，标记需要垃圾回收的对象，可与用户线程并行
3. 最终标记：处理并发标记过程中可能出现并发问题的部分，短暂暂停用户时间
4. 筛选回收：更新region的统计数字，根据回收价值排序，根据用户希望的停顿时间选择对应的region进行回收。把需要回收的region中存活对象移动到空region中，需要暂停用户线程，因为存在对象的移动，但是这一部分是多线程并行进行的，只是不能和用户线程并行

**<font color='red'>优点</font>**：

- 关注吞吐量和停顿时间的最佳平衡
- 可以全区域垃圾回收
- 分region的内存布局
- 按照收益优先回收效益高的
- G1基于标记-整理和标记-复制两种算法，相比CMS不会产生较多的内存碎片，内存利用率高

缺点：

- 垃圾收集过程的内存占用更高
- 回收程序执行负载高，小内存应用上，相比CMS效率较差。
- 堆内存容量（CMS和G1效率）平衡点：6GB-8GB

#### 2.5.8 ShenandoahGC垃圾收集器

低延迟的垃圾回收器，G1的精进版。

#### 2.5.9 ZGC垃圾回收器

低延迟垃圾回收器

#### 2.5.10 Epsilon不进行垃圾回收

这不能进行垃圾回收，适合那些应用生命周期短，只运行一小会的那种，只需要虚拟机正确分配内存，在堆内存耗尽之前结束任务，就不会出现内存溢出的错误

### 2.6 垃圾回收器的选择

#### 2.6.1 根据三个性能指标选择

一般根据应用程序的主要关注点去选择合适的垃圾回收器；

需要低延迟（服务器级别的、网络应用）的应用程序：选择低延迟的垃圾回收器，比如ZGC、G1这一类

需要高吞吐量（像数据分析和科学计算类的任务）的应用程序：选择任务处理量更多的那些垃圾回收器

对于内存占用（嵌入式应用和客户端应用）关注度高的应用程序：选择那些垃圾回收时内存占用低

#### 2.6.2 根据虚拟机运行状态调整收集器

分析虚拟机状态和垃圾收集器的日志分析，当前应用更适合哪一类垃圾回收器。有许多的虚拟机参数可以用来输出日志进行分析查看应用运行状态和GC状态信息

## 3 JVM子系统



## 4 程序编译和代码优化



## 5 JVM并发

`-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp`：编译模式执行代码，并查看反汇编代码和指令

### 5.1 JMM内存模型

#### 5.1.1 工作内存

Java线程中读取线程所需要的变量等内容的主存的副本，类似操作系统中的缓存，实现和缓存类似的功能

#### 5.1.2 主内存

实际的物理内存（实际上只是物理机的一部分，虚拟机分配到的物理内存）

一些规定：

- 线程的工作内存保存了线程使用的变量的主内存副本
- 线程对变量的操作必须在工作内存中进行，不能直接读写主存数据
- 不同线程之间不能访问彼此的工作内存数据
- 线程之间通信和值传递通过主内存来实现

### 5.2 Java线程

#### 5.2.1 线程实现

目前的JVM线程大都是偷懒型做法，都是基于操作系统本身的线程来进行实现的

1:1实现：一个Java线程对应一个内核线程

1:N实现：一个内核线程（进程）内部对应多个Java线程

N:M实现：混合了内核线程和用户线程的实现，多个用户线程对应到轻量级进程，多个内核线程对应多个用户线程

##### 5.2.1.1 基于内核线程实现

内核线程：直接交给操作系统内核来进行切换、调度。每个内核线程好似内核的分身，操作系统可以借此处理多个任务。

1:1关系是指内核线程和轻量级进程的1:1对应，一般应用程序不会直接使用内核线程

内核线程和轻量级进程的缺点就是线程的创建、同步等需要进行系统调用，需要用户态到内核态的切换。

优点：

- 由于底层操作系统已经实现好了，只需要使用内核线程就可以很方便管理
- 实现简单

缺点：

- 开销大
- 需要系统调用（用户态到内核态切换）
- 系统可以创建的数量不多

##### 5.2.1.2 基于用户线程实现

用户线程：不是内核线程的其他线程，狭义的用户线程指在用户空间建立运行的线程，内核感知不到用户线程的存在。用户线程创建、同步、删除都是用户态就可完成，相比内核线程，需要的资源消耗更少，因此用户线程的数量相对就更多。

优点：

- 消耗资源少
- 可创建的用户线程更多

缺点：

- 线程创建、销毁和同步等需要用户自己实现考虑
- 实现相对比较复杂

##### 5.2.1.3 基于轻量级进程实现

轻量级进程：内核线程的一种高级接口，每个轻量级进程都是一个独立的调度单元，某个轻量级进程的阻塞不会影响整个进程的阻塞，但是轻量级进程需要消耗一定的内核资源，轻量级进程的数量不可能太多

#### 5.2.2 Java线程调度

抢占式调度：线程的执行时间交由操作系统来进行分配，一般采用优先级进行分配，优先级高分配的执行时间多，越容易执行。不会出现一个线程阻塞导致系统阻塞的问题

协同式调度：线程的工作执行结束之后，主动通知系统切换到另外一个线程上。由于线程执行时间的不确定，可能导致系统错误或者崩溃，但是实现比较简单

### 5.3 Java协程和纤程

由于线程本身的实现机制，导致其所需要的资源比较多，所以一般一个系统中能够创建的线程数量有限，当你遇见了任务量特别多的情况（==现在大部分任务都是时间短但是任务的请求多==），再加上线程切换、调度和同步等需要进行内核态的切换时，所带来的开销更大，就很容易导致系统资源不够，出现问题。

#### 5.3.1 协程

协程的实现就是基于如何减少内核态的切换或者直接不需要内核态的切换这一目的进行的

==将保护、恢复线程线程以及线程调度的工作从操作系统交由用户和程序员==，这样就可以避免这一类的开销

<font color='red'>有栈协程</font>：大致的原理就是通过在内存里面划出一片空间来模拟调用栈，只要其他线程中的方法入栈和出栈遵守提前约定好的规则，不破坏共享内存，就可以完成线程的来回切换调度执行，避免了内核态的切换开销

无栈协程：本质是一种有限状态机，状态保存在闭包中，比有栈协程恢复调用栈更轻量级，但是功能较少

优点：

- 更加的轻量级，节省内核态的切换开销
- 可以创建的协程数量变多了，可以处理的任务变多

缺点：

- 协程实现是应用层的内容，实现麻烦
- 调度器、调用栈的实现是关键，比较麻烦
- 如何保证协程之间的同步以及如何保证切换协程不影响线程？

#### 5.3.2 纤程

有栈协程的一种实现方式，微软最早出现这一词。Java的Loom项目正在研发这一纤程的实现

- 轻量级/用户线程，由JVM调度
- 可以创建的数量很多

纤程并发的代码分为两部分：

- 执行过程：用来维护执行纤程，保护和恢复上下文状态
- 调度器：负责编排需要执行的代码的顺序

### 5.4 线程安全

线程安全：当多个线程同时访问一个对象时，如果不需要考虑线程在执行环境下的调度和交替执行，也不需要进行额外的同步操作，调用这个对象的行为都可以获得正确的结果，则称这个对象时线程安全的

#### 5.4.1 Java的线程安全等级

##### 5.4.1.1 不可变

不可变的对象一定是线程安全的，在Java语言中，final定义的类（没有发生this逃逸情况）下是线程安全的，final定义的共享数据是线程安全的

##### 5.4.1.2 绝对线程安全

不管运行环境是怎么样，绝对线程安全的对象不需要再进行额外的同步操作，可以保证对象的行为可以获取到正确的结果。Vector的实现就不是绝对线程安全的

多个线程同时访问vector对象，一些删除元素，一些获取元素，如果不进行额外的同步操作，当某个时刻访问刚刚删除的元素就会出现错误

##### 5.4.1.3 相对线程安全

保证对象的单次操作满足线程安全。Java中许多线程安全类属于这种类型（HashTable、Vector等）

##### 5.4.1.4 线程兼容

对象本身不是线程安全的，但是调用端通过某些操作保证同步的线程安全措施可以安全使用的情况

ArrayList、HashMap等都是线程兼容

##### 5.4.1.5 线程对立

无论如何都没有办法保证线程安全

#### 5.4.2 线程安全实现方式

##### 5.4.2.1 互斥同步

采用锁机制

##### 5.4.2.2 非阻塞同步

采用CAS机制

##### 5.4.2.3 无同步措施

比如采用ThreadLocal（线程本地存储）这一类的方式

可重入代码也是线程安全：一个方法的返回结果是可预测的，只要输入相同的数据都能返回相同的结果，就满足重入性，就是线程安全的
