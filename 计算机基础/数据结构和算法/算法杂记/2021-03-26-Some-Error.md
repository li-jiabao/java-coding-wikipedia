---
title: 堆排序
author: lijiabao
date: 2021-03-26 14:30
categories: ["DataStruture and Alogrithm"]
tags: ["DataStruture and Alogrithm"]
---

记录一下自己在编写代码过程中遇到的一些常见错误，和一些基本知识的回顾总结

## 常见错误

### 数组越界错误

在设计或者访问数组元素的时候，要仔细思考怎么避免数组越界的问题，特别在算法的运行过程中，索引值一定要仔细考虑设计。

当然碰见错误不要慌张，根据报错的堆栈信息，一层层的去抽取信息，找到最终的错误代码所在，也可以通过debug打断点的操作来快速定位错误代码位置。

### `NullPointerException`

对于对象类型的引用，如果引用没有初始化或者对象指向了null，这时候访问该引用可能就会出现该错误信息。

对于这类错误，一定要仔细观察报错堆栈信息，推测null引用位置，然后考虑如果修改避免`NullPointerException`

### 面对对象程序设计

对于面对对象编程设计时，对于变量的封装，某些方法的封装，以及静态成员和实例成员的设计，一定要提前考虑好。

比如：静态方法一般用在下列情况时：

- 不需要访问实例变量，只需要访问静态成员变量时，就可以将方法设计为静态方法
- 不需要访问对象的状态，需要的参数都只需要通过显式参数提供，不需要利用this关键字访问隐式参数
- 静态方法还可以用在创建静态工厂方法来获取对象实例（这种访问的优点是可以改变对象所属的类型，可以设计比较清楚的方法名指示获取对象实例的用途）

### 变量

实例变量是具有初始值的，而局部变量需要初始化，不然编译会不通过。变量的定义最好尽量靠近变量第一次使用的地方，这样代码逻辑可读性会更好。

在任何的方法体内部不要定义和实例变量同名的局部变量，这可能会遮蔽实例变量。比较好的一种访问实例变量的方法是通过this关键字来访问。

### 执行顺序

静态域的初始化是按照代码的先后顺序执行的，且静态代码块中定义的变量是一次性的临时变量。



继承的时候代码的访问顺序：

1. 父类的静态变量和静态代码块
2. 子类的静态变量和静态代码块
3. 父类非静态对象，父类非静态代码块
4. 父类的构造方法
5. 子类非静态对象和非静态代码块
6. 子类构造函数

继承时的特性：

- 父子关系
- 父类的对象引用可以指向子类对象（**多态**）
- 子类找不到会向上查找，但是不会出现向下查找的情况，父类不可以使用子类的方法
- 子类可以重写和调用父类的方法
- 子类继承父类所有的成员，构造器并不属于父类成员，因此子类并不继承，但是子类可通过super关键字调用父类构造器。虽然父类的私有成员并不能直接访问，但是可以使用反射机制来访问

成员方法和变量的执行：

- 方法编译的时候会查看左边代码，运行时看右边（父类索引指向子类对象时，调用子类方法）
- 成员变量编译时看左边，运行时也看左边