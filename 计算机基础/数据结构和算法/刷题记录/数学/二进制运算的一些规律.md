# 二进制的一些规律

二进制中1的个数和它是否时奇偶数有关系：

- 当数字为奇数时代表其前面一个数是偶数，也就是第一位的数字是0，那么这个奇数就比前面的那个偶数多1，因此，1的个数多1
- 数字为偶数，相当于前面的某个奇数右移一位，此时他的位数并不发生改变，而这个奇数就是当前偶数左移一位得到

## 只出现一次的数字（其他元素出现三次）

解题思路：每个数字都出现三次的话，这个时候二进制的每一位数字都出现三次，此时如果多出来一个数字，那么这个数字上1的位数就会增加，导致不再是三的倍数，那么此时所有二进制位数对1出现的次数对3取余，那么就能找出唯一的那个数字的二进制位为1的情况，也就得出了该数字

方法一：有限状态自动机
各二进制位的 位运算规则相同 ，因此只需考虑一位即可。如下图所示，对于所有数字中的某二进制位 1 的个数，存在 3 种状态，即对 3 余数为 0, 1, 2

由于二进制只能表示 0, 1，因此需要使用两个二进制位来表示 33个状态。设此两位分别为 two，one ，则状态转换变为：

若输入二进制位 1，则状态按照以下顺序转换：

- 如果第一位为1，进位，one为0，two为1，相当于取反
- 第一位为0，one变为1，two不变，相当于异或

若输入二进制位 0 ，则状态不变。

接下来，需要通过 状态转换表 导出 状态转换的计算公式 。首先回忆一下位运算特点，对于任意二进制位 xx ，有：

异或运算：x ^ 0 = x ， x ^ 1 = ~x
与运算：x & 0 = 0 ， x & 1 = x
计算 one方法：

```
if two == 0:
  if n == 0:
    one = one
  if n == 1:
    one = ~one
if two == 1:
    one = 0
```

引入 异或运算 ，可将以上拆分简化为：

```
if two == 0:
    one = one ^ n
if two == 1:
    one = 0
```
引入 与运算 ，可继续简化为：

```
one = one ^ n & ~two
```

计算 two方法：

由于是先计算 one，因此应在新 one的基础上计算two 。

```
two = two ^ n & ~one
```

以上是对数字的二进制中 “一位” 的分析，而 int 类型的其他 31 位具有相同的运算规则，因此可将以上公式直接套用在 32 位数上。

遍历完所有数字后，各二进制位都处于状态 0000 和状态 0101 （取决于 “只出现一次的数字” 的各二进制位是 11 还是 00 ），而此两状态是由 oneone 来记录的（此两状态下 twostwos 恒为 00 ），因此返回 onesones 即可。

```java
class Solution {
    public int singleNumber(int[] nums) {
        int ones = 0, twos = 0;
        for(int num : nums){
            ones = ones ^ num & ~twos;
            twos = twos ^ num & ~ones;
        }
        return ones;
    }
}
```

复杂度分析：
时间复杂度 O(N)： 其中 N位数组nums 的长度；遍历数组占用 O(N) ，每轮中的常数个位运算操作占用 O(32×3×2)=O(1) 。
空间复杂度 O(1)： 变量 ones , twos 使用常数大小的额外空间。