---
title: 数据结构类型和特性
author: lijiabao
date: 2021-03-18 13:00
modifyDate: 2021-03-29 16:00
categories:  ["DataStruture and Alogrithm"]
tags:  ["DataStruture and Alogrithm"]
---
主要介绍常用的数据结构的类型，以及这些数据结构的特点和缺点，以及数据结构对应操作的时间复杂度

## 数据结构的类型和特性

常见的数据结构有：数组、栈、队列、链表、树、图以及这些数据结构衍生出来的一些变体。这些变体的出现往往都是为了解决原始数据结构的缺点和不足而发明的。不同的数据结构之间可能会有相互借鉴融合而产生一些更高效方便的数据结构。如：有序数组就是为了解决数组查找慢而引申出来的，双端队列则是基于双向链表而实现的多用队列。

### 类型

#### 数组

数组的特点：

- 通过索引可以获取指定索引位置的值
- 数组的大小在创建时就需要指定，如果数组尺寸设计过大，资源浪费，过小会出现数组溢出
- 插入数据比较方便，因此对于元素插入或者变动比较频繁的情况比较适用

数组的复杂度：

- 查找和删除的复杂度为O(N)
- 插入的时间复杂度为O(1)

#### 有序数组

有序数组的特点：

- 数组中的元素按照指定键进行排序
- 查找的速度比无序数组快得多
- 有序数组在查找频繁的情况下十分有用
- 插入和删除的操作较为频繁，无法高效工作

有序数组的复杂度：

- 插入和删除时间复杂度为O(N)
- 查找若是采用二分查找，只需要O(lgN)复杂度

#### 栈

栈的特点：

- 先进后出，插入和获取都只能操作栈尾元素
- 栈满和栈空都需要报错提示异常
- 栈的效率：入栈和出栈的时间复杂度都为常数

栈的用途：

- 数学算术表达式解析：碰见括号就需要进行处理
- 括号或者配对符号的匹配（左符号先出现的要比后出现的后匹配）：左符号入栈，遍历到右符号出栈进行匹配，看是否配对成功
- 单词逆序，遍历单词推入栈，然后再出栈就获取了逆序的单词

#### 队列

队列的特点：

- 先进先出，插入元素在队列尾，获取元素在队列首
- 队列空或者满都需要报错提示异常
- 队列中插入元素和删除数据的时间复杂度均为O(1)常数级别
- 对于删除元素之后队列元素的移动带来的消耗，可以利用链表来实现从而提高效率

双端队列：

- 一个两端都是结尾的队列，队列的每一端都可以插入数据项和移除数据项
- 双端队列是一种多用途数据结构，即可完成队列操作也可以完成栈的操作，但是并不常用

优先级队列：

- 优先级队列有一个队头，有一个队尾，并且也是从头移除数据项
- 优先级队列的数据项按照关键字的值排序，关键字最大的或者最小的在队头
- 在数据项插入时就需要保证按照顺序插入
- 优先级队列插入操作需要O(N)，删除则需要O(1)

#### 链表

为了解决无序数组的搜索效率低、有序数组插入效率低和数组大小不可改变的的问题，就出现了链表这一种数据结构。数组之外第二广泛使用的通用存储数据结构。

链表的特征：

- 链表包含链表对象和结点对象
- 链表对象一般包含一个引用指向first
- 结点对象包含自己的数据项和一个指向下一结点的引用next，next为null时表示到达链表末尾

- 可以用于取代数据作为其他存储结构的基础，如栈和队列。除非需要频繁通过下标随机访问各个数据，不然很多使用数组的地方都可以使用链表
- 链表中的数据被包含在结点中，结点是某个类的对象，每个结点对象包含了存储的数据字段以及下一个结点的引用字段。链表对象有一个字段指向链表的第一个结点，也可以指定一个链表最后一个结点的字段。

**单链表**具有的操作（LinkedList类：只含有一个数据项，第一个结点的引用，惟一链表需要维护的信息）：

- 在链表头插入数据项
- 链表头删除数据项
- 遍历列表显示链表中的内容

**双端列表**（和单列表类似，只是新增了最后一个结点的引用）：

- 双端列表允许很方便的在链表的结尾添加删除元素
- 还可以利用双端列表实现队列的操作

**基础链表的效率：**

- 链表的表头插入和删除速度很快，仅需要改变一两个引用值，所以花费O(1)的时间
- 查找、删除和在指定结点后面插入都需要搜索链表中的一半结点，需要O(N)次比较，平均需要访问N/2个数据项。数组中这些操作也需要O(N)次比较，但是链表效率更高一点，因为不需要移动元素。当复制时间大于比较时间时，链表的增加的效率更明显
- 链表的另外一个优点是：需要多少元素结点就可以使用多少个，数组在创建时大小就固定了（可能出现数组太大效率低下或者数组太小空间溢出）
- 向量Vector是一种可以扩展的数组，通过可变长度解决问题，但是经常只允许以固定大小增量扩展（例如快溢出增加一倍容量小于四分之一缩减一半容量）虽然很好解决数组的固定大小问题，但是内存使用效率上来水比链表的低

**有序列表**：

- 链表中的数据按照某个键进行排序
- 有序列表的删除只限于删除头部结点。也可定义find和delete来查找删除指定结点
- 大多数需要有序数组的情况可以使用有序链表，有序链表优于有序数组的地方是插入的速度以及可以随意增加删除，内存不受限制

**有序链表效率**：

- 插入和删除某一项最多需要O(N)次比较（平均N/2）因为必须沿着链表一步一步走才能找到正确位置。
- 在O(1)时间内找到或者删除最小或最大值（因为总是在表头）
- 如果需要频繁查找最小值且不需要快速插入，有序链表是个不错选择（优先级队列使用有序链表实现）

**双向链表**（有两个指针，一个指向前一个结点pre，一个指向后一个结点next）：

- 相比普通的链表，反向遍历比较困难，使用`current.next`就可以到达下一个结点，但是并不能反向引用到之前的结点
- 需要有两个引用，一个指向先前结点，一个指向之后的结点
- 缺点就是每次插入或者删除结点时，都需要处理四个结点的引用，而不是两个。因为多了两个引用，结点占用空间变大了
- 遍历：有两种，一种向前遍历displacyForward，一种向后遍历displayBackward
- 插入：insertFIrst、insertLast和insertAfter插入元素，在链表为空时，需要注意last和first的设计
- 删除：deleteFirst、deleteLast和deleteKey，在链表为空时，注意first和last的情况

**双端队列**（基于双向链表）：

- 双端队列可以随意从任何一头插入，双向链表的提供了双端队列的实现

**迭代器：**

- 需要遍历链表并在某些特定的结点执行一些操作，这就需要实现迭代器
- 数组中迭代器可以通过下标进行索引，链表中没有下标。为了实现这种操作，需要实现一个迭代器类
- 迭代器类包含对数据结构中数据项的引用，并用来遍历这些结构的对象。这个迭代器类中包含对当前结点的引用current

迭代器的API

| 迭代器API方法          | 解释                         |
| ---------------------- | ---------------------------- |
| `void reset()`         | 把迭代器设置在表头           |
| `Node nextNode()`      | 迭代器移动到下一个结点       |
| `Node getCurrent()`    | 返回迭代器指向的结点         |
| `boolean atEnd()`      | 如果迭代器到了表尾，返回true |
| `void insertAfter()`   | 迭代器后面插入一个新结点     |
| `void insertBefore()`  | 迭代器前面插入一个新结点     |
| `void deleteCurrent()` | 删除迭代器指向的当前结点     |

#### 二叉树

二叉树特点：

- 结合有序数组和链表的优点
- 树中查找数据项的速度和有序数组中查找一样快，并且插入和删除数据项的速度和链表一样

#### 红黑树

平衡二叉树的一种实现，利用红色节点和黑色节点的属性加入，进行平衡二叉树的构建

#### 2-3-4树

#### 哈希表

利用哈希算法计算得到元素存储的索引位置，然后将其存储到数组中，访问元素的时候先通过哈希算法计算索引，然后在利用该索引访问数组元素

#### 堆

也是类似的一种二叉树结构，只是二叉树的父节点和子节点之间存在大小关系，父节点大于子节点的时候是大顶堆

父节点小于子节点的时候是小顶堆。

## 并查集

主要用来解决元素分组的问题，管理的是一系列互不相交的集合，支持两种操作：

- 合并（union）：把两个不相交的集合合并为一个集合，两个不相交的元素进行PK，谁的头节点PK胜利，该节点就作为新集合的头节点。
- 查询：查询两个元素是否在同一个集合中。不断地向上访问节点知道访问到头节点，如果两个头节点为同一个，则这两个元素在同一个集合中

举例：给定两个人，查看这两个人是否具有亲戚关系，这一问题就可以使用并查集来解决

为了提高并查集合并的效率：

- 路径压缩：因为并查集只关注元素本身以及其对应的根节点，因此这一方法就是将元素的父节点设置为根节点即可，这样，即使将一个集合和另外一个集合进行了合并，需要遍历的节点数也不会很多，将路径压缩的尽可能的短。路径压缩之后并查集的时间复杂度已经很低了，如果时间复杂度要求很高的时候，可以考虑下一种优化
- 按秩合并：下图中，左边的合并方式没有右边的合并好，右边的合并并没有增加数的深度，这就有利于时间复杂度的提升。合并的时候，尽量将深度小的往深度大的集合上去合并。

![image-20210915154538762](https://gitee.com/Jia_bao_Li/img/raw/master/img/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%8C%89%E7%A7%A9%E5%90%88%E5%B9%B6.png)

## 图

描述一组对象的结构。其中某些对象之间是相关的，这些相关的对象成为顶点（节点），每个相关节点对组成边，图是离散数学的研究对象之一。

图分为两大类：

- 有向图：图的边规定方向（出边和入边）的时候，这时候组成的图就是有向图
- 无向图：图的边没有规定方向

图的存储方式：

- 数组（邻接矩阵）表示
- 邻接表表示：

图的遍历：

- 深度优先搜索：
- 广度优先搜索：



### 数据结构的特性

| 数据结构 |                            优点                            |                         缺点                         |
| :------: | :-------------------------------------------: | :--------------------------------------: |
|   数组   |          插入快，如果知道下标，可以非常快速的存取          |                 查找删除慢，大小固定                 |
| 有序数组 |                     比无序的数组查找快                     |                 删除插入慢，大小固定                 |
|    栈    |                     提供后进先出的存取                     |                    存取其他项很慢                    |
|   队列   |                   提供先进先出方式的存取                   |                    存区其他项很慢                    |
|   链表   |                       插入快，删除块                       |                        查找慢                        |
|  二叉树  |            查找、插入、删除都快（树保持平衡时）            |                     删除算法复杂                     |
|  红黑树  |             查找、删除、插入都快，且树总是平衡             |                       算法复杂                       |
| 2-3-4树  | 查找、删除、插入都快，且树总是平衡，类似的树对磁盘存储有用 |                       算法复杂                       |
|  哈希表  |                 关键字已知存取几块，插入快                 | 删除慢，不知道关键字则存取很慢，对存储空间使用不充分 |
|    堆    |            插入、删除快，对最大数据项的存储很快            |                  对其他数据项存取慢                  |
|    图    |                       对现实世界建模                       |                   有些算法慢且复杂                   |





## 抽象数据类型

抽象：不考虑细节的描述和实现，抽象是事务的本质和总要特征

面对对象编程中，一个抽象数据类型就是一个类，且不考虑它的实现，它是对类中数据的描述和能够在数据上执行的一些列操作（方法）以及如何使用这些操作的说明。每个方法如何执行任务的细节不包含在内，作为类的用户，只被告知可以调用哪些方法，如何调用，以及可望得到的结果，但是不包含具体的实现和运作。

实际上，抽象数据类型就是一些API接口，定义了方法名返回值和需要传入的参数，有API接口的详细描述。

抽象数据类型类似一种程序设计方法：

- 首先需要考虑这个程序需要的一些操作，比如需要在数据上实现的操作
- 设计定义好完整的ADT列表（也就是程序所需要的API接口）
- ADT完全设计定义好之后，再去实现细节问题
- 实现抽象可以让你在不干扰用户代码的情况修改API接口的实现逻辑