# 数据结构

## 数组

随机访问，下标访问。因此如果有要求需要随机访问某个位置的元素时，首先应该考虑数组。

访问元素的时间复杂度O(1)，删除的时间复杂度较高O(n)，因为需要改变元素的位置

## 链表

顺序访问，如果对于数据的前后顺序有一定的要求，可以采用链表这一基础数据结构，当然也有基于这一基本结构发展而来的顺序访问结构：树、双向链表

增加和删除元素的时间复杂度低O(1)，查找元素的时间复杂度O(n)

## 双向链表

有两个指针，一个指针指向前一个结点，另外一个节点指向后一节点，除此之外，还需要头节点和为节点作为哨兵节点监控整个链表

## 二叉树

有两个指针，一个左指针，一个右指针，分别指向当前的节点的两个子节点.

平衡二叉树的查找效率高一些O(log(n))，增加删除也不低O(log(n))

## 红黑树（平衡二叉树）

为了维持树的平衡算法较为复杂，采用了一种有颜色属性的机制来实现平衡二叉树的构建

## List无界数组

可以动态改变大小的数组，当元素的数量快要超出范围时，进行数组的扩容并将数组复制到新扩展的数组中去

## List链表实现

利用链表的非顺序存储的机制，可以随机增加元素，因此不需要像数组一样进行动态改变大小，只需要记录指针即可

## 栈

先入后出的访问特点，增加和删除时间复杂度为O(1)，访问随机元素O(n)

## 队列

先入先出的访问特点。增加和删除时间复杂度为O(1)，访问随机元素O(n)

## 优先级队列

优先级高的或者优先级低的查找和删除很快O(1)，直接访问第一个元素和删除第一个就可以。

增加元素的时间复杂度O(logn)，基于堆实现

## 堆

一种特殊的数组，数组实现的二叉树结构，父节点比子节点都大（大顶堆）或者都小（小顶堆）的一种结构

如果数组的第一个元素使用的话：父节点为i，左右子节点分别为`2*i+1，2*i+2`

第一个元素空闲的话：父节点为i，左右子节点分别为`2*i，2*i+1`

## 双端队列

队列的首尾都可以增加和删除元素，基于链表的一种实现。

## Map哈希表

元素的查找、增加很快O(1)，删除稍慢也是O(1)（出现哈希冲突，如果有链表的话O(n)，使用红黑树O(log(n))）

哈希表的hashcode不同的对象数组其得到的哈希值都是不相等的，除非你自己创建一个对象重定义hashcode方法。

例如字符串中的hashcode：如果字符串是equals的，那么这两个字符串虽然不是同一个字符对象，但是hashcode一样

### 某个和hashcode相关的问题：异位词数组

给定一个字符串数组 `strs` ，将 **变位词** 组合在一起。 可以按任意顺序返回结果列表。

**注意：**若两个字符串中每个字符出现的次数都相同，则称它们互为变位词。

```java
import java.util.Arrays;

class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> res = new ArrayList<>();
        Map<String,Integer> map = new HashMap<>();
        for (int i=0;i<strs.length;i++) {
            char[] chars = strs[i].toCharArray();
            Arrays.sort(chars);
            String key = new String(chars);
            if (!map.containsKey(key)) {
                map.put(key,res.size());
                res.add(new ArrayList<String>());
            }
            res.get(map.get(key)).add(strs[i]);
        }
        return res;
    }
}
```



## 有序哈希表

根据元素插入的先后顺序来排序哈希表。这种实现的方式是通过哈希表加上链表的结构来实现的。

根据实际的需求可以选择使用什么链表：如果只是插入不怎么删除元素的时候，直接选取单列表也是可行的。

如果需要每次需要删除最近最少访问的元素的时候，可以使用双向链表来辅助实现。当某个元素访问之后，立马将这个元素的位置移动到链表末端。这样的话就可以实现按照时间和访问先后有序了

## 并查集

主要用来解决元素分组的问题，管理的是一系列互不相交的集合，支持两种操作：

- 合并（union）：把两个不相交的集合合并为一个集合，两个不相交的元素进行PK，谁的头节点PK胜利，该节点就作为新集合的头节点。
- 查询：查询两个元素是否在同一个集合中。不断地向上访问节点知道访问到头节点，如果两个头节点为同一个，则这两个元素在同一个集合中

举例：给定两个人，查看这两个人是否具有亲戚关系，这一问题就可以使用并查集来解决

为了提高并查集合并的效率：

- 路径压缩：因为并查集只关注元素本身以及其对应的根节点，因此这一方法就是将元素的父节点设置为根节点即可，这样，即使将一个集合和另外一个集合进行了合并，需要遍历的节点数也不会很多，将路径压缩的尽可能的短。路径压缩之后并查集的时间复杂度已经很低了，如果时间复杂度要求很高的时候，可以考虑下一种优化
- 按秩合并：下图中，左边的合并方式没有右边的合并好，右边的合并并没有增加数的深度，这就有利于时间复杂度的提升。合并的时候，尽量将深度小的往深度大的集合上去合并。

![image-20210915154538762](https://gitee.com/Jia_bao_Li/img/raw/master/img/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%8C%89%E7%A7%A9%E5%90%88%E5%B9%B6.png)

## 图

描述一组对象的结构。其中某些对象之间是相关的，这些相关的对象成为顶点（节点），每个相关节点对组成边，图是离散数学的研究对象之一。

图分为两大类：

- 有向图：图的边规定方向（出边和入边）的时候，这时候组成的图就是有向图
- 无向图：图的边没有规定方向

图的存储方式：

- 数组（邻接矩阵）表示
- 邻接表表示：

图的遍历：

- 深度优先搜索：
- 广度优先搜索：



# 数据结构的选择问题

对于实际问题当中应该选取什么数据结构，应该首先分析问题的需求，看问题的着重点在什么地方

如果问题需求是要求随机访问元素：一般都是需要选择数组或者数组实现的一些数据结构来完成目的

如果问题的需求是要求添加删除和访问元素的时间复杂度为O(1)，可以选取哈希表。

如果是同时需要满足多个要求：比如既需要满足添加和删除元素时间复杂度为O(1)，同时还需要能够随机访问存储的元素的时候，往往是需要多个数据结构的整合，哈希表+数组

如果要实现最近最少使用缓存算法：不仅需要满足增加和删除元素O(1)，还需要可以顺序访问，将最开始最老增加的元素给删除，这个时候，就需要哈希表+链表实现这一需求。

而且对于特定的语言，如果该语言本身实现的一些数据结构使用并不方便或者效率有点不高时，可以自己去实现这一类数据结构。