# 设计模式

继承的缺点：

- 继承是侵入式的，只要有继承，就具有了父类的属性和方法
- 降低代码的灵活性，子类多了父类的约束
- 增加了耦合性，父类的常量/变量/方法发生变动后，还需要考虑子类的修改

继承的特性：

- 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法
- 子类中可以增加自己特有的方法
- 当子类重载父类的方法时，方法的传入参数要求要比父类方法的输入参数更宽松，但是子类方法的返回值要比父类的更严格

## 设计模式的目的

- 代码重用性（同一功能的代码不同多次编写）
- 提高可读性（编程规范性，便于阅读理解）
- 提高可扩展性（需要增加新功能的时候比较方法，改动不会波及到太多的位置）
- 提高可靠性（增加新功能后，对原来功能没有影响）
- 降低耦合度（模块内连接紧密，模块和模块之间的连接不紧密）

设计模式是针对面向对象编程的语言的一种设计模式。

## 七大原则

- 开闭原则：总原则，对修改关闭，对扩展开放。所有的软件实体需要变化升级的时候，不要去修改原来的代码。对于那些需要变化或者会发生变化的代码，不要和不变化的代码混合在一起，而是将需要变化扩展的代码抽离出来，对这一部分代码进行抽离封装扩展（把会发生变化的代码抽离出来并进行封装，便可轻易的改动或者扩展这一部分的代码）
  - 避免测试复杂化：通过扩展实现的变化，只需要对扩展部分进行单元测试即可，只要保证修改部分满足要求即可
  - 提高代码复用性：避免因为修改某个小功能或者bug导致整个项目中去修改相关的内容
  - 提高可维护性：开发新功能的时候，扩展总是要比修改更容易
- 单一职责原则：接口、类、方法只负责做一件事。但是切分也是有限度的，粒度不要太小就可
  - 降低代码的复杂性：因为只有指定的某一类功能
  - 可读性提高：代码的功能单一，实现逻辑更明确，代码也就更容易读懂
  - 修改类带来的风险减低

- 里氏替换原则：所有引用基类的地方必须能够透明的使用子类的对象，也就是子类可以扩展父类的功能，但是不能改变父类原有的功能
  - 子类实现父类的抽象方法，但是不能覆盖父类的非抽象方法
  - 子类中可以增加自己特有的方法
  - 当子类重载父类的方法时，方法的传入参数要求要比父类方法的输入参数更宽松，但是子类方法的返回值要比父类的更严格
- 依赖倒置原则：高层模块不应该直接依赖地层木块二者应依赖于抽象，抽象不应该依赖实现细节，而是实现细节依赖于抽象（实际就是类需要实现接口和抽象类）
  - 每个类尽量都有接口或者抽象类
  - 变量的表面类型尽量使用接口和抽象类
  - 任何类尽量不要从具体类里面派生（尽量不要使用类继承）
  - 尽量不要复写基类中实现的方法
  - 结合里氏替换原则使用
- 接口隔离原则：将那些宝行功能过多的接口拆分称为更小更具体的接口
  - 一个接口只服务一个子模块或者业务逻辑
  - 尽量压缩接口内的方法，保证都是有用的，避免接口臃肿
  - 接口压缩也是有限度的，压缩粒度太小，结构就会变复杂，可维护性降低
- 最少（迪米勒法则）原则：只和有需要通信的实体或者类之间调用，保证尽可能的降低耦合度，提高模块的相对独立性。
  - 方法中尽量不引入类中不存在的对象
  - 不要暴露过多的公共方法和公共变量
- 合成复用原则：新对象里面使用一些已有对象，新对象通过委派达到代码复用的效果
  - 尽量多的采用has-a关系而不是is-a关系
- 简单原则：化繁为简，以最终简单为目标，框架思维来编程

## 设计模式的种类

- 创建型模式：提供创建对象的机制，增加已有代码的灵活性和可复用性
- 结构性模式：介绍如何将类和类组装成较大的结构，并同时保证结构的灵活和高效
- 行为模式：负责对象间的高效沟通和职责委派



创建型模式：

- 工厂方法
- 抽象工厂
- 单例
- 原型
- 生成器（创建者）

结构性模式：

- 适配器模式
- 桥接模式
- 组合模式
- 装饰模式
- 外观模式
- 代理模式
- 亨元模式

行为模式：

- 观察者模式
- 责任链
- 命令模式
- 迭代器模式
- 备忘录模式
- 观察者模式
- 状态模式
- 策略模式
- 模板方法
- 访问者
- 解释器模式