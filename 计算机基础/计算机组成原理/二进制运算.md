# 二进制运算

## 小数的表示

通过将小数乘以2再与1进行比较，大于1，添加1，否则添加0，一直循环操作直到达到精度的限制

如：0.65->  第一位是1.3取1，然后0.6取0，然后1.2取1，然后0.4取0，然后0.8取0...

最后得到：0.10011...

## 负数表示

正数取反运算后再加1，起始也就时补码的运算方式。

## 正负数的二进制区分

正负数的表示：看二进制数的最高位1，如果高位为0，表示正数，高位为1表示负数

## 为什么负数比正数范围多？

因为最高位为1，表示负数，为0表示正数的机制引起的，0属于高位为0的类别

## 二进制逻辑运算

- 逻辑与（&）：两个都为1时才为1
- 逻辑或（&）：只要有一个1时才为1
- 逻辑非（!）：0变为1，1变为0
- 逻辑异或（^）：一个为1，一个为0时为1

## 二进制位移运算

- 带符号右移（>>）：二进制数向右移位，高位补（0或1）符号位为1时高位补1，为0时补0
- 左移（<<）：二进制数向左移位，低位补0；
- 无符号右移（>>>）：向右移位，高位补0

## 二进制加减乘除（a，b）

二进制算数运算本质上到最后都是加法运算：

怎么利用二进制的逻辑运算和位移运算实现加减乘除？
```java
public class BinaryMath {
    // 加法实现
    public int addRec(int a,int b) {
        return b==0?a:addRec(a^b,(a&b)<<1);
    }
    
    public int add(int a,int b) {
        int ans = 0;
        while (b!=0) {
            a = a^b;
            b = (a&b)<<1;
            ans = a;
        }
    }
    
    // 减法实现
    public static int subtract(int a,int b) {
        b = ~b;
        return add(a,add(b,1));
    }
    
    // 正数乘法
    public static int mul(int a,int b) {
        int ans = 0;
        while (b!=0) {
            if ((b&1)==1) ans = add(ans,a);
            a <<= 1;
            b>>=1;
        }
        return ans;
    }
    
    // 正数除法
    public static int divide(int a,int b) {
        int ans = 0;
        int mul = b;
        int count = 1;
        while (a>=b) {
            if (a<mul) {
                mul>>=1;
                count>>=
                continue;
            }
            a = subtract(a,mul);
            ans += count;
            mul<<=1;
            count<<=1;
        }
        return ans;
    }
}
```

加法运算：首先让两个数进行与运算，计算出需要进位的数位，然后右移一位，再和两个数的异或值相加，因此需要循环进行相加，直到其中一个数为0，就可以获取加法运算结果。（((a&b)<<1)+(a^b)），可以用递归的方式，或者用循环

减法运算：（将被减数b取补码之后和a相加，就得到减法运算结果）

乘法运算：（计算b个a相加的结果，为了加快速度，可以采用翻倍递进相加的方法进行）

除法运算：（实际就是看a能最多减去多少个b）