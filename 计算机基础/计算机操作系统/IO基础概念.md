# IO基础内容

## 1 几个重要概念

同步：任务执行的时候等到这个任务执行完毕再继续执行接下来的任务

异步：IO的读写工作由操作系统完成，操作系统完成之后通知进程来继续后续的处理

串行：任务按照顺序排列，只有前面的任务完成才可以继续执行下一个任务

并发：同时处理大量的任务，在任务等待的时候且CPU空闲可以执行另外的任务，这样在短时间内看起来好像这几个任务时一起执行的一样

并行：真正的任务的同时执行，但是这个的实现需要硬件的支持，需要多个CPU才可能同时执行多个任务

阻塞：发起了IO操作之后，会一直等待IO的完成

非阻塞：发起IO操作之后，不会傻等IO的完成，而是直接返回可以进行其他的操作

- 基于轮询的非阻塞，可以返回进行其他的操作，但是需要定时轮询IO的状态，看是否就绪，就绪就进行数据的处理，未就绪就继续干其他事情
- 基于中断的非阻塞：当IO操作完成之后，设备会发起中断给操作系统，操作系统再去调度原来的程序回来执行数据的处理

## 2 专业术语

内存分页：更好的管理内存和分配内存，采用了分页机制，将内存分成很多个指定大小的页，以页为单位访问分配内存

页表：操作系统建立的物理内存和进程逻辑内存的映射

快表（TLB）：为了减少内存访问次数，减少CPU和内存之间速度的不同步，提高CPU的利用率，在缓存中将一部分常用的页表数据保存下来，下次访问的时候可以直接从缓存中读取不用再去访问内存。

缺页异常：当程序执行的时候，发现自己需要的数据或者代码段在内存中不存在，就会产生异常通知操作系统从外部存储中将需要的这一部分数据或者代码段加入到内存中，如果内存不够，就需要进行页面置换淘汰一部分页面（会根据指定的页面置换算法进行），然后将需要的这一部分数据加载到内存并返回程序继续执行

页面置换算法：当内存不够分配新的数据时，需要进行页面置换，将现在内存中不需要的页面或者很久不用的页面或者脏页替换掉，保证现在需要的数据可以进入到内存中

虚拟内存：例外外部存储作为辅助内存空间，提高内存的利用率和可以执行的程序数量

系统调用：系统调用是需要消耗资源，当系统调用被频繁执行的时候，速度就很慢

脏页：执行过写操作的内存页被称之为脏页，脏页在页表中有一个标志位记录的，为1表示脏页，脏页的标志位在改进时间轮页面置换算法中会被使用。

page cache（页缓存）：从实际物理内存中开辟出来的内存空间，用作操作系统的磁盘读写缓存，比如客户端文件读写时，不直接写回磁盘，而是直接写入page cache中，表示已经写入完成，用来提升IO性能（减少磁盘和CPU速度相差过大的问题）

局部性原理：缓存淘汰的根据，程序在执行的一段较短时间内，执行指令地址和指令操作数地址限定在一定的区域内

缓冲区：用作临时的数据存储的技术，先将数据复制到缓冲区，缓冲区的数据在一定时间会保留，当这一部分数据被备份保留下来之后，才会从缓冲区中删除。内存缓冲区是为了协调磁盘速度和CPU速度不匹配而出现的一种技术，可以减少CPU中断次数。缓冲区技术在计算机CPU、内存和磁盘中都存在。

IO优化：文件的读写先加载到内存中，内存的读写效率比磁盘高很多，提高了CPU利用率（让CPU和磁盘设备充分的并行）。

Flush：将内存中的文件数据刷回磁盘的方法（系统调用），或者当该部分内存页面将要被置换的时候，就会写回磁盘保存持久化下来，因此Redis、MySQL数据库需要持久化的原因，如果不及时持久化的话，很有可能处于内存当中的数据会丢失，影响太大。

BufferIO：设定了缓冲区来存储需要加载到内存的数据，只有当缓冲区达到一定的大小时，才会产生系统调用将这一部分内容加载到内存中。而普通的IO在每次调用write都会执行系统调用写入到内存中。这也就是两者效率之间的差异所在

GDT全局描述表：将这些数据整齐的排列在内存的某个位置，然后将内存的起始地址和有效设定的个数放在CPU内部称为GDTR的特殊寄存器。一般这个GDT是在操作系统启动的时候加载进入内存的

IDT中断描述符记录表：效果类似GDT，内部也有IDTR的寄存器。主要是用来记录中断的信息、数据、处理函数的地址等

### 系统调用公共入口

系统调用本质就是用户空间代码需要执行某些内核才能进行的操作，比如：

系统调用的五大功能：

- 进程调度
- 设备管理
- 文件管理
- 进程通信
- 信息维护

`int 0x80`是一个中断函数的地址，这个地址保存的其实是一个通用函数，这个通用函数是用来调用系统调用之前加入CPU寄存器的指令内容。

`system_call()`是所有系统调用的公共入口。

### 为什么设置内核态和用户态系统权限？

为了保障系统的安全，不让用户的意外操作导致系统关键数据和代码损坏

### 为什么系统调用可以保证系统安全？

系统调用方法是通过在用户空间执行特定的一行系统调用来调用对应的处理逻辑。而这关键的处理其实最后还是交由内核完成，只是最后的结果是返回到用户空间的中断断点继续执行。执行系统调用的时候会进行现场保护和正确性检查，这就保证了安全，系统调用最后执行的处理函数等的地址是没有暴露给用户的有，因此很难被用户错误操作。

功能：

- 保护现场
- 进行正确性检查
- 根据系统调用号跳转到具体的内核函数
- 内核函数执行完毕调用set_system_call()，完成系统调用返回前的检查工作
- RESTORE_ALL恢复现场并执行iret指令返回用户断点

## 3 Unix的五种IO模型

输入的两个阶段：

- 等待数据准备好
- 从内核中向进程复制准备好的这部分数据

### 3.1 阻塞式IO

当进程发起IO请求的时候，进程会被阻塞，直到IO请求完成（IO等待数据准备完成、内核缓冲区数据复制到进程缓冲区两部完成）

![image-20211023195617922](https://gitee.com/Jia_bao_Li/img/raw/master/img/%E9%98%BB%E5%A1%9E%E5%BC%8FIO%E6%A8%A1%E5%9E%8B.png)

只有当进程发起的IO请求操作成功进程才可以继续向下执行，否则进程阻塞或者出错

### 3.2 非阻塞式IO

调用IO请求的时候，不直接睡眠当前进程，而是让这个进程不断发起IO请求，直到IO请求调用返回一个准备就绪，进程开始处理数据。在IO请求的过程中，进程一直处于工作状态。这样的一种状态是轮询内核，查看需要的数据是否准备就绪

![image-20211023195657202](https://gitee.com/Jia_bao_Li/img/raw/master/img/%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8FIOmoxing%20.png)

### 3.3 IO复用

IO复用的实现是让阻塞发生在系统调用上（如select、poll），而不是阻塞在进程的IO调用。

当select或者poll中的数据准备就绪时会通知进程，告知进程数据可用，然后再取数据进行处理

优点：

- 可以等待多个描述符就绪

#### IO多路复用

开启一个单独的线程来检测所有的套接字Socket，用来检测socket的IO是否完成，完成就启动相应的程序进行处理

JAVA的NIO主要使用于网络编程

select：底层时数组，利用轮询socket句柄的方式检测是否IO完成有数据了

poll：底层时链表，也是利用轮询的方式。

epoll：底层是红黑树（保存在内核中，便于快速的查找插入和删除）+链表（存储就绪的事件），以链表存储就绪事件减少内核空间复制到用户空间的资源消耗。触发方式：水平触发和边缘触发

### 3.4 信号驱动式IO

使用信号机制，当描述符就绪时，让内核发送SIGIO信号通知进程就绪，这一种方式称之为信号驱动式IO

![image-20211023200201939](https://gitee.com/Jia_bao_Li/img/raw/master/img/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8%E5%BC%8FIO%E6%A8%A1%E5%9E%8B.png)

开启信号驱动式IO功能，通过系统调用安装信号处理函数，这个系统调用立即返回，进程可以继续工作，并未被阻塞。

当数据就绪，内核为该进程产生一个SIGIO信号。可以在信号处理函数调用recvfom读取数据，然后通知进程数据准备好待处理，也可以直接通知进程读取处理数据

### 3.5 异步IO

告知内核启动IO操作，并让内核将整个的IO操作（准备就绪等待和数据复制到进程缓冲区）执行完再通知进程

和信号驱动式IO的区别在于：

- 异步IO是内核通知IO操作何时完成
- 而信号驱动是内核通知何时可以启动IO操作

![image-20211023200835671](https://gitee.com/Jia_bao_Li/img/raw/master/img/%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B.png)

#### 异步

异步适合的场景：

- 大量的任务请求
- 这些任务大量的都是IO操作，需要等待IO事件
- 像CS架构应用这一类场景，很多的请求都是访问数据库这一类操作，采用异步可以让用户访问更流畅效果更好不同过多的等待。同时也更好的利用系统资源，最大化的利用系统资源

异步优点：

- 提高了系统资源利用率，可以解决性能瓶颈
- 提高系统的吞吐量
- 提高整体请求的成功率，提高服务的质量

## Java的几种IO模型

BIO：同步阻塞IO模型，对于每一个请求都开启一个线程来进行处理，这一类处理缺点就是每个请求都要创建线程，系统的开销很大，应用线程池可以改善线程创建销毁的开销，但是对于系统的硬件资源和系统资源要求高，不支持很高的并发量

NIO：同步非阻塞IO模型，利用IO多路复用轮询IO请求，当IO完成再去执行之后的操作

AIO：异步非阻塞IO模型，客户端的请求都是由操作系统完成之后通知进程取用



## 追踪IO系统调用的命令

`strace`命令用来追踪系统调用和信号，示例：`strace -ff -o out java Hello`监听程序执行过程中相关的系统调用并输出到文件中，文件名带上线程号后缀

`/proc/进程号`查看Linux下的具体进程的数据和内容，通过查看`/proc`目录下面对应的进程号对应的文件，可以清楚进程内部的内容

系统调用：

- `socket`创建socket连接
- `bind`：绑定监听端口
- `listen`：监听连接
- `accept`接收客户端连接
- `clone`创建一个线程
- `recv`等待接收数据

