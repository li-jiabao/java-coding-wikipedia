# TCP三次握手四次挥手

## 1 三次握手

### TCL连接状态

客户端：CLOSED(关闭) -> SYN_SENT(连接请求发送) —> ESTABLISHED(连接建立) -> FIN_WAIT1(等待上层断开连接) -> FIN_WAIT2(等待服务端断开连接) -> TIME_WAIT(等待最后的连接断开，保证断开连接的ACK服务端会收到) -> CLOSED

服务端：CLOSED -> LISTEN(监听连接请求) -> SYN_RECV(接收到连接请求) -> ESTABLISHED(收到ACK之后连接创建) -> CLOSE_WAIT(等待连接断开) -> LAST_ACK(等待客户端断开连接的ACK) -> CLOSED

![image-20211019194456943](https://gitee.com/Jia_bao_Li/img/raw/master/img/TCP%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81.png)

### 1.1 为什么要进行三次握手？

<font color='red'>目的是为了确认接发双方的接收和发送能力是否正常，为后面的可靠数据传输做准备。</font>

第一次握手：服务端可以确认发送端的发送是否正常以及自己的接收能力是否正常

第二次握手：客户端可以确认自己的接收能力和服务端的发送能力是否正常

第三次握手：客户端确认自己的接发正常，服务端最终确认自己的接发能力正常

### 1.2 三次握手过程

![image-20210904171206300](https://gitee.com/Jia_bao_Li/img/raw/master/img/image-20210904171206300.png)

图中字符的含义：

- SYN：连接请求/接收 报文段
- ACK：确认报文段
- seq：发送的第一个字节的序号
- ack：确认号，希望接收到的下一个字节的序号

#### 1.2.1 第一次握手

客户端向服务端发送一个SYN报文（SYN=1），并指明客户端的初始化序列号ISN(x)（seq=x）表示本报文段发送的数据的第一个字节的序号，客户端处于SYN_Send状态

#### 1.2.2 第二次握手

服务端收到了来自客户端发送的请求报文之后，发送一个SYN报文作为应答（SYN=1），并指定自己的初始化序列号ISN(y)（seq=y），同时还会将客户端的初始序列号+1作为哦确认好ack的值，告诉客户端已经收到服务端发来的报文，希望收到的下一个数据的字节的序号是x+1，服务器处于SYN_REVD

#### 1.2.3 第三次握手

客户端收到了服务端发送过来的报文之后，会发送一个ACK确认报文，将服务段的初始化序列值+1作为ack，告知下一个希望接收的字节序号y+1，表明接收到了服务端发过来的报文，并将自己的序列号+1（seq=x+1），客户端发送之后，就进入了Established状态，待到服务器接收到ACK报文之后，也进入Established状态。表示两者之间的连接已经确定。

### 1.3 ISN值固定的吗？

ISN的功能：让对方知道接下来接收数据的时候如何按序列号组装数据。

当某一端为了建立连接发送SYN时，会为连接选择一个初始序号。ISN随时间而变化，每个连接的ISN不同。

如果ISN是固定的话，攻击者很容易猜测出后续的确认好，借此可以仿造数据包攻击。

因此ISN是动态生成的

### 1.4 三次握手过程中可以携带数据吗？

第三次握手可以携带

前两次握手绝对不可以携带数据

假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，然后疯狂重复发 SYN 报文的话（因为攻击者根本就不用管服务器的接收、发送能力是否正常，它就是要攻击你），这会让服务器花费很多时间、内存空间来接收这些报文。

⭐ **简单的记忆就是，请求连接/接收 即 `SYN = 1` 的时候不能携带数据**

而对于第三次的话，此时客户端已经处于 `ESTABLISHED` 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以当然能正常发送/携带数据了。

### 1.5 半连接队列

服务器在第一次收到客户端的SYN请求之后，就处于了SYN_RCVD状态，此时双方还没创建连接，服务器会将这种状态的连接请求放到一个**半连接队列**

**全连接队列**：是放置三次握手完成之后创建的连接的队列

## 2 三次握手的异常情况

### 2.1 <font color='red'>SYN泛洪攻击</font>

客户端在短时间内伪造大量的虚假不存在的IP地址（或者客户端故意不回复第三次握手包），并向服务器不断发送SYN包。server会回复确认包，但是因IP不存在，只能等到超时结束后才能结束，这个时候这些虚假无效的请求会一直占着半连接队列的容量，导致其他正常SYN请求被丢弃，从而引起服务器的网络阻塞甚至系统瘫痪

### 2.2 第一次握手丢失，服务器客户端怎么处理？

如果第一次握手丢失，这个时候服务端并不知道有连接请求，因此，服务端并不清楚，因此也不会做出处理

客户端：会进行SYN请求的重发（只要在规定时间内没有收到ack确认，均会认为该包丢失，需要进行超时重传，重传总共会尝试三次，时间间隔分别5.8s、24s、48s，总共约75s重传时间

### 2.3 第二次握手丢失

也就是说服务端发送了ACK确认包，但是客户端并没有收到该包。

客户端：客户端因为没有收到ack，会认为超时丢包，也会进行重传，和第一次握手丢包的操作类似，客户端重传[SYN]

服务端：因为没有收到客户端的ack，认为超时，需要进行重传，这个时候服务端会重传[SYN ACK]，依次等待3、6、12s之后重传。在重传次数之内，没有收到ACK，就会关闭该连接（半连接队列删除）

### 2.4 第三次握手丢失，服务器客户端怎么处理？

第三次握手丢失：服务器在发送了ACK确认包之后，没有收到客户端的响应确认包

服务器：会进行首次重传，如果还没有收到，继续重传，如果达到了最大重传次数还没有收到响应，就会将该连接从半连接队列中删除。一般重传等待时间不一定相同，一般是以指数增长，例如间隔：1，2，4，8...当服务端处于 SYN-RCVD 状态下时，接收到客户端真实发送来的数据包时，会认为连接已建立，并进入 ESTABLISHED 状态。

客户端：客户端这个时候已经将确认ACK发送出去建立了单方面的连接，客户端便会开始发送数据，这个时候如果服务器收到了客户端的数据，但因为二者之间的连接还没成功，就会回复一个RTS包响应，表示服务端出错

## 3 四次挥手

四次挥手功能：<font color='red'>用来释放TCP连接，这个释放客户端和服务端都可以主动发起</font>

### 3.1 为什么要进行四次挥手？

1. 确保两端的连接都正常释放
2. 因为TCP是半连接，一端在结束了一方的发送功能之后，还能够接收数据
3. 为了将接发连接都关闭，进行四次确认消息就显得理所当然
4. <font color='red'>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</font>

**通俗的来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手**。

例子：A 和 B 打电话，通话即将结束后，A 说 “我没啥要说的了”，B 回答 “我知道了”，于是 A 向 B 的连接释放了。但是 B 可能还会有要说的话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，于是 B 向 A 的连接释放了，这样整个通话就结束了。

![image-20210904191653420](https://gitee.com/Jia_bao_Li/img/raw/master/img/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

图中符号的意思：

- FIN：连接中止位（请求）
- seq：发送的第一个字节的序号
- ACK：确认报文
- ack：确认号，希望收到的下一个数据的第一个字节的序号

### 3.2 四次挥手的过程

3.2.1 第一次挥手

客户端发送一个FIN请求，告知服务器我要和你中止连接（FIN=1），报文中会指定一个序列号seq=u，并停止继续发送数据，主动关闭TCP，连接，此时的客户端处于FIN-WATI状态，等待服务端的确认

`这个时候客户端处于FIN-WAIT-1状态，等待远程TCP发来的连接中断请求或者等待远程TCP的中断请求的ACK确认`

3.2.2 第二次挥手

远程TCP响应另一端发起的连接中断请求，回复确认ack消息，并把客户端的序号值+1作为ACK报文的序列号值，告知客户端已经收到连接中断请求

`此时的服务端处于CLOSE-WAIT状态，等待本地用户发起的连接中断请求（应用程序）`

此时的客户端收到了ack之后，便会将其和服务端的发送连接断开，此时的TCP处于半连接状态

`这个时候的客户端会进入FIN-WAIT-2状态，等待服务端的连接中断请求`

3.2.3 第三次挥手

服务器端也想要和客户端断开连接（没有数据要再发送了）（本地用户发起（应用程序）），和客户端的第一次挥手一样，发送一个FIN报文，且指定一个序列号。

`此时服务端处于LAST-ACK状态，等待客户端连接中断请求的确认`

3.2.4 第四次挥手

客户端收到了服务端的连接中断请求，和服务端的ack响应一样，会将服务端的FIN序列号+1作为ack确认值seq=u+1

此时客户端处于TIME-WAIT状态，等待足够时间确保服务端收到确认消息再彻底断开连接

🚨 <font color='red'>注意 ！！！</font>这个时候由服务端到客户端的 TCP 连接并未释放掉，**需要经过时间等待计时器设置的时间 2MSL（一个报文的来回时间） 后才会进入 `CLOSED` 状态**（这样做的目的是确保服务端收到自己的 ACK 报文。如果服务端在规定时间内没有收到客户端发来的 ACK 报文的话，服务端会重新发送 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文给服务端）。服务端收到 ACK 报文之后，就关闭连接了，处于 `CLOSED` 状态。

## 4 四次挥手的异常情况

### 4.1 连接中断请求（FIN）的包丢失

这个情况不管是客户端还是服务端发起的，处理情形类似，类似考虑就可：

客户端：因为没有收到服务端响应的FIN ACK确认，会触发重传（一定时间内或者未能收到ack），如果达到最大重传次数还没有收到ack，会直接关闭连接

服务端：对这种情况无感知，并不会做出任何响应

### 4.2 服务端的ACK消息包丢失

服务端：因为已经发送了ack确认包，这个时候服务端已经进入CLOSED-WAIT，进入断开连接前的准备。服务端向断开连接，便会向客户端发起FIN ACK连接中断请求，<font color='red'>这个请求涵盖服务端ACK的响应序号。只要FIN ACK没丢，客户端可以凭借FIN ACK的响应序号，直接从FIN-WAIT1直接进入TIME-WAIT状态</font>

客户端：由于没有收到服务端的确认包描绘进行重传，服务端收到之后，会再重传ack

### 4.3 服务端的FIN ACK包丢失

服务端：超时之后会进行重传

客户端：此时处于FIN-WAIT2或者FIN-WAIT-1（服务端ACK丢失）状态，等待接收到FIN ACK消息

### 4.4 客户端回复的ACK丢了

服务端：并没有接收到来自客户端的响应，会进行重传，知道超时之后主动断开，或者重传的FIN客户端收到，回复RST消息

客户端：因为已经发送了ACK，此时的客户端处于TIME-WAIT，等待时间是两次包传送时间（2MSL）

### 4.5 服务端发送了ACK，服务端跑路

服务端发送了ACK之后，客户端现在还处于FIN-WAIT-1或者FIN-WAIT-2状态，但是因为永远接收不到FIN ACK，一直不能转到TIME-WAIT。TCP并没有对这种情况的处理机制，系统会接管这个状态，当TCP-FIN-timeout超时之后，客户端直接切换到CLOSED状态，断开连接。

### 4.6 客户端收到了ACK，客户端跑路

客户端：收到了服务端发来的ACK消息，之后客户端跑路，这个时候服务端发送的FIN ACK接收不到ACK响应消息，会不断进行重发，重试，这个时候服务端的状态：LAST-ACK

这个时候服务器会出现两种情况：

1. 超时之后，服务端主动断开连接
2. 如果跑路之后有新的客户端接入，会再次发送SYN期望建立连接，但是这个会服务端被忽略，直接回复FIN ACK消息，新客户端接收到，并不认识，因此回复一个RST消息给服务端，服务端收到RST消息后，主动断开连接

<font color='red'>RST消息</font>：TCP首部中的6个标志比特之一，表示重置连接、复位连接，是一种重置消息，表示当前错误，应回到初始状态。

