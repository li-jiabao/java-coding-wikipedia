# 接口幂等性

## 什么是幂等？

幂等是一个数学和计算机科学的概念：

- 数学中：指的是f(x)=f(f(x))，像绝对值就是幂等设计的，无论你执行多少次，最后的结果都是一样的
- 计算机科学中：指的是一次请求和多次请求最后的结果都是一样的。

## 为什么需要幂等？

举个例子：像转账这个场景，如果你由于网络的问题重复提交了多个转账请求，如果没有设计为幂等的，那么就会出现多次转账的情况，这种情况肯定谁都不乐意碰见，因此这就是为什么需要幂等。

- 此外还涉及到幂等的情况就是在消息队列中，防止消息的重复消费
- 同时点击了多次提交订单的操作，如果不设计为幂等，就会出现多笔订单的问题

## 接口超时的处理方案

对于上面的网络超时出现的重复问题，一般有两种解决方案：

- 下游系统提供一个查询接口，如果接口超时，查询记录，成功记录就执行成功的逻辑，失败就执行失败的处理逻辑
- 下游接口支持幂等：上游调用方出现超时情况直接重试即可

方案一对于消息队列的重复消费不是很好，一般就是要求接口在设计时就考虑到幂等性的设计

## 接口如何实现幂等？

幂等意味着一个请求的唯一性，因此对于幂等性的设计，一般都需要一个ID来标识请求，这个请求必须是全局唯一的

- 可以采用唯一索引标识控制幂等性
- 采用数据库主键ID控制幂等

### 全局的唯一ID

唯一ID的生成对于同一个数据库的话，可以直接采用数据库的主键ID，如果是分布式系统，那么就需要使用分布式ID的生成算法，如：snowflake（雪花）算法，百度（Uidgenerator）的算法、美团的（Leaf）算法等等，实现分布式唯一ID的方式有多种。

雪花算法的具体实现和原理：雪花算法的ID有64位

- 第1位：标识为正还是负，一般都是正数，因此一般第一位都是0
- 接下来的41位：时间戳，一般是距离1970-1-1日的时间戳（毫秒数）
- 接下来的10位：代表计算的ID，防止冲突
- 剩余的12标识每台机器上生成ID的序列号，允许在一个毫秒内创建多个ID

### 幂等设计的流程

每一次请求都将请求的ID保存起来，使用请求的ID来标识每一个请求，如果ID相同表示是同一个请求

大致的流程：

![image-20220104232826803](https://gitee.com/Jia_bao_Li/img/raw/master/img/%E5%B9%82%E7%AD%89%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png)

## 实现幂等的方案

### 1 数据库主键select+insert

首先使用select查询判断请求是否已经存在，存在就直接返回成功

不存在就执行insert操作插入请求，如果插入出现冲突，表示请求已经存在。

为什么先使用select再insert？

防止高并发场景下的问题，出现过多的冲突错误

### 2 数据库主键+insert

直接插入数据：冲突说明请求存在直接返回错误，就是上面方式去除select

数据库去重和幂等设计不太一样：

- 前者只是防止重复数据
- 后者需要保证相同请求返回相同的结果

### 3 状态幂等

为什么需要状态幂等？

因为有时候一个请求往往存在多种状态，需要保证各种状态下的幂等性

那么这一类有状态的幂等性的设计就可以根据每一次数据库请求之后影响的行数来判断之前是否已经有相同的请求存在了。影响行数为1说明之前没有这个状态，为0则表示之前存在

### 4 抽取防重表

每次请求先去防重表中插入，防重表出现冲突则直接返回，插入成功则执行流程，这只是一种具体业务上的处理方法，具体的实现和前面提到的select+insert是一样的

### 5 token令牌标识

利用token来标识是否已经处理过：

- 客户端申请获取token，服务端生成token，存储到redis并返回给客户端
- 客户端带着请求的token直接发起请求，然后服务端进行校验

一般token这一类的数据会借助redis来存储记录

流程：

- 申请token
- 服务端根据请求生成唯一的token，并存储到redis，然后返回给客户端
- 客户端带着这个token请求，如果请求不存在，直接返回
- 存在则执行业务逻辑，执行成功之后将token删除，没有删除的话后续请求到了验证通过会直接进行业务处理

### 6 悲观锁

认为在修改数据的时候会有其他的任务或者线程来修改我的数据，因此直接对数据进行加锁操作。执行完其他的人才可以访问加锁的这个资源

- 非原子性的事务处理逻辑

```
begin;  # 1.开始事务
select * from order where order_id='666' # 查询订单，判断状态
if（status !=处理中）{
   //非处理中状态，直接返回；
   return ;
}
## 处理业务逻辑
update order set status='完成' where order_id='666' # 更新完成
commit; # 5.提交事务
```

- 加锁之后原子性的事务逻辑

```
begin;  # 1.开始事务
select * from order where order_id='666' for update # 查询订单，判断状态,锁住这条记录
if（status !=处理中）{
   //非处理中状态，直接返回；
   return ;
}
## 处理业务逻辑
update order set status='完成' where order_id='666' # 更新完成
commit; # 5.提交事务
```



### 7 乐观锁

悲观锁在数据库中借助版本号来处理，如果版本号可以对上才会进行数据的修改或者业务的处理，否则不处理

版本号最好是自增且唯一的，防止ABA问题的出现。

### 8 分布式锁





HTTP的post和PUT方法不是幂等设计的，多次提交可能导致结果不一样的