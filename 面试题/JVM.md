# JVM

![](https://cdn.jsdelivr.net/gh/li-jiabao/NoteImg@main/img/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA.png)

## 运行时内存区

### .1 JVM堆

（线程共享区域）

这是JVM最主要的一块内存区域，新创建的对象都在这个内存区域内部。

Hotspot 的 JVM堆分为老年代和新生代，新生代分为：eden:fromSurvior:toSurvior=8:1:1

一般新建的对象都会被放到eden区，如果对象过大eden，可能会被直接放到老年代中。

对象会被放到老年代的几种情况：

- 大对象：超过参数设置大小的对象会被放入到老年代
- 当对象的存活年龄超过设置的参数值，默认15，就会晋升到老年代

JDK1.7之后，将字符串常量池从方法区移入到了堆内存中

### .2 JVM方法区

（线程共享内存区域）

存放的内容：

- 虚拟机加载的类型信息
- 常量
- 静态变量

### .3 JVM栈

（线程私有）

分为本地方法栈和虚拟机栈：这块内存区域用来存放方法调用的时候的栈帧的数据结构的内存区域

存放的内容：

- 局部变量表（对象引用、基本数据类型、字节码指令地址）

### .4 程序计数器

（线程私有）

当前线程执行指令字节码行号指示器，程序的分支、循环、跳转等功能都是依靠程序计数器来实现的

### .5 运行时常量池

Class信息，方法区的一部分内容，存放的是类加载过后的符号引用和符号引用转换而来的直接引用。

运行时常量池不只是存放编译期间加入的内容，还可以动态加入（运行时加入）（string的intern()方法）

### .6 直接内存

借助native方法直接分配内存的这一部分区域，然后在Java队中通过某个对象来实现对这一部分内容的访问

## Java对象

### .1 对象创建

1. 首先判断该对象是否已经被加载过，查看是否具有相关的符号引用
2. 没有加载过就需要进行类加载过程
3. 为对象分配内存（内存大小在加载的时候就已经确定下来了）
4. 内存变量初始化零值（初始值）
5. 对象头设置（设置锁信息，对象的hashCode，分代年龄信息，线程ID等）
6. 对象的构造函数执行，按照程序员想要的内容进行初始化构造

### .2 内存分配方式

指针碰撞：指直接将内存指针向后移动对象大小的方式来为对象分配内存的方式（维护了一个空闲内存的指针，当需要分配内存的时候，只需要将指针向空闲内存处移动指定大小即可）。如果内存比较规整，可以采用这种分配方式。

空闲列表：维护一个空闲内存的列表，当有分配内存需求的时候，从空闲列表中选择合适的内存大小来进行分配即可。适合内存不是很规整的情况。

### .3 对象布局

对象头：markword和类型指针

- markword：64位，存放锁信息、线程ID、hashCode、对象年龄等
- 类型指针：指向对象类型元数据的指针，标识属于哪一个类

![image-20210913235949432](https://gitee.com/Jia_bao_Li/img/raw/master/img/Java%E5%AF%B9%E8%B1%A1%E5%A4%B4markword.png)

实例数据：存放各种类型的字段内容

对象填充：保证对象大小是8的倍数

### .4 对象访问方式

句柄访问：

直接指针：



## 垃圾（可回收对象）的判定

引用计数法：通过记录对象的引用个数来分析对象是否可回收。但是不能解决循环引用的问题。

可达性分析：通过某些确定不会被回收的对象和其拥有的引用，判断某些对象是否可以通过这些root对象到达这些对象

## 类加载

### 1 类加载过程

#### 加载

1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

可以从任何地方加载二进制流到内存中来，正是由于这种灵活性，出现了后面很多有创造性的技术比如从zip压缩文件中读取、动态代理、加密文件读取（加载过程中解密）

在这个过程中还可以自定义类加载器来加载你需要加载进来的所有内容

#### 验证

- 文件格式验证：验证文件是否以0xcafebabe开始，验证版本号是否满足JVM的要求
- 元数据验证：验证字节码描述的信息是否满足Java语言规范的要求
- 字节码验证：验证字节码是否可以正确执行，保证运行时不会对JVM产生危害
- 符号引用验证：验证类的各类信息：方法签名、是否可以找到指定的类、是否具有指定类、字段和方法的访问权限

#### 准备

- 为类中静态变量分配内存并设置初始值的阶段，如果类变量声明为final，那么在准备阶段就会赋值需要的值

#### 解析

- 将常量池中的符号引用转换为直接引用的过程；

- 符号引用：可以是任意形式的字面量，只要保证使用的时候可以定位到目标即可，符号引用的目标不一定是存在虚拟机内存中。
- 直接引用：对应于指向内存中某个目标的指针、或者是能够定位到目标的句柄或者偏移量。如果存在直接引用，那么虚拟机内存中一定存在引用的目标。

#### 初始化

- 执行`<clinit>`构造器的流程，这个构造器是JVM手机类中的赋值语句和静态代码块合并组成的，手机顺序和类中定义的顺序一样。静态代码块可以给后面定义的赋值，但是不可以访问。父类的静态语句块先于子类的静态语句块执行。如果类中没有赋值语句和静态代码块，JVM可以不给这个类创建`<clinit>`构造器
- 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成
  `<clinit>`()方法。但接口与类不同的是，执行接口的`<clinit>`()方法不需要先执行父接口的`<clinit>`()方法，
  因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也
  一样不会执行接口的`<clinit>`()方法。

使用

卸载



### JVM中的默认类加载器

- Bootstrap ClassLoader：负责加载JDK自带的rt.jar包中的类文件，是所有类加载器的父类
- Extension ClassLoader：负责加载Java的扩展类库，·`jre/lib/ext`或`java.ext.dirs`系统属性下指定的目录下加载类
- Application ClassLoader；负责从classpath中加载类文件

### 双亲委派模型

类加载首先是自底向上检查类是否已经加载，如果还未加载就向父类加载器请求加载，如果请求到Bootstrap还没有加载就向下委派子类，逐渐向下委派加载，如果到了自定义类加载器还是加载不成功，就会抛出ClassNotFoundException

```java

/**
* 通过指定的名字来加载类
* 默认的方法实现通过下面的流程来加载类：
*   1 调用findLoadedClass(Strnig name)检查当前类是否已经被加载过了
*
*   2 如果还没有调用就调用父类类加载器的loadClass()递归加载类
*   如果parent没有，就会使用JVM内置的默认的三个类加载器
*
*   3 调用了所有的父类加载器加载之后还没有找到就需要执行findClass()方法来找寻自定义的类加载器来加载

* 如果找到了这个类，并且resolve是true，将会调用resolveClass(Class)方法来解析这个找到的Class对象
* 
* 建议子类在继承ClassLoader的时候重写findClass()，而不是重写loadClass()方法
*
* 除非方法被覆盖，否则在整个类加载过程中，这个方法使用getClassLoadingLock()找到的锁进行同步锁定，避免了类加载并发的发生
*
* @param  name
*         类的类名
*
* @param  resolve
*         是否找到了之后进行解析这个类
*
* @return  返回找到的Class对象
*
* @throws  ClassNotFoundException
*          没找到就会抛出ClassNotFoundException异常
*/
protected Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        // First, check if the class has already been loaded
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
            }

            if (c == null) {
                // If still not found, then invoke findClass in order
                // to find the class.
                long t1 = System.nanoTime();
                c = findClass(name);

                // this is the defining class loader; record the stats
                PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```



### 双亲委派机制的好处？

- 避免重复加载同一个类：每个类加载器在进行类加载的时候都先询问父类加载器是否已经加载，如果所有的父类都没有加载自己才回去加载这个类，这样就可以避免多个加载器重复加载的局面
- 保证核心类不被覆盖篡改：如果用户写了和Java类库里面同名的包，如果不采用双亲委派机制，可以随意加载类，就会出现Java类库被覆盖的风险，这样就会影响程序的稳定性和安全性，此外如果不是双亲委派机制，外界有人利用这个漏洞，可以攻击java程序，给用户带来很大的风险。
- 保证加载的都是同一个Class对象：不管是哪一个类加载的类，最终都会委托到顶层类加载器进行加载，保证任何加载器加载最终都得到的是同一个类对象

### 双亲委派机制的缺点？

子类加载器可以使用父类加载过的类，但是父类加载器不能使用子类加载器加载过的类。就好像Java中的继承关系一样。

Java的SPI机制就是用来让第三方实现某些接口从而提供一些新的功能和模块，类似于JDBC就是SPI，这些SPI接口由Java核心类提供，具体实现在第三方，这些提供者是交给Boostrap ClassLoader来加载，但是第三方的实现类是由自定义的ClassLoader加载，这个时候顶层的类加载器不能使用第三方的自定义类加载器加载过的类

### 解决方案——打破双亲委派机制

自定义类加载器：如果只是继承ClassLoader并且重写findClass()，这种方式不会打破双亲委派机制

想要打破双亲委派机制，那么需要自己重写loadClass()方法，然后用自己实现的方法来加载类即可。

不过在重写loadClass方法的时候，需要注意Object.class是对象的顶级类，如果类加载全改，在加载的时候会找不到Object，这样加载就会出现问题，因此这个时候需要分类，将我们需要使用自定义类加载的和使用默认类加载的类给分类，然后针对不同的情况使用不一样的加载方式

### Tomcat打破双亲委派机制实现？





## 内存溢出

### 发生OOM的原因？

- Java程序在运行的时候，分配的内存就不足以运行该程序或者分配的内存很少，运行一段时间之后使用内存就满了
- JVM垃圾回收的速度赶不上对象创建的速度导致了内存溢出
- 内存泄漏导致的内存溢出：疏忽错误而使得程序未能释放或者无法释放已经不再使用的内存。往往就是像打开了文件或者socket连接，但是没有关闭这些连接、静态变量引用大对象

### 发生OOM的内存区域？

除了程序计数器不会发生内存溢出之外，其他内存区域都会出现内存溢出

### JVM进程挂掉的原因？

Windows下的JVM不是手动关闭就是OOM导致的

Linux下的话除了OOM会导致，Linux内部有一种保护机制：OOM Killer，这个机制是为了保证系统在可用内存较少的情况下仍然可以使用，但是需要根据进程分值大小排序杀掉一些评分高的进程来回收内存

### 快速定位问题？

查看日志文件是不是存在out of memory：kill process这样的日志显示。如果是这种情况，说明是Linux下的OOM Killer将这个进程给杀掉了，这种情况腾出一部分内存来保证JVM的继续运行

如果不是，就可以确定是OOM造成，这样的话，可以通过查看进程的对战信息来查看具体是什么原因导致的OOM

如果没有生成dump文件，是直接内存的问题，生成了可能是堆也可能是元空间的问题

visualvm可以查看dump日志信息



OOM建议：

- 开启`-XX:+HeapDumpOnOutOfMemoryError`开启内存溢出写dump日志文件

- 开启`-XX:HeapDumpPath=`指定日志文件输出路径
- 堆内存不要设置的过大，设置的很大，发生OOM时生成的dump文件也可能很大，建议8G
- 可以主动dump内存分析，只是主动dump会导致STW的出现

## JVM常用的一些调优参数

