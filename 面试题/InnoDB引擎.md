# InnoDB引擎

![InnoDB逻辑存储结构](https://gitee.com/Jia_bao_Li/img/raw/master/img/InnoDB%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png)

## 内存

### 1 缓冲池

基于磁盘存储，但是磁盘的记录管理按照页的方式进行，但是由于内存和磁盘之间的速度差异，导致如果进行磁盘IO等待的话，需要耗费较长的时间，因此InnoDB采用了借助内存作为缓存的这样一种方式，来减少磁盘IO的次数和等待时间。这就类似于CPU缓存和内存之间的关系，减少等待时间，更充分的利用CPU和内存资源。

对数据库的读取操作，都是先在缓冲池中查找，看是否存在，不存在从磁盘中读取到内存中，下次访问缓冲池就可以很快的获取到数据，而不用再等待磁盘的IO时间

对数据的修改操作，也是先修改在缓冲池中的也，然后以一定的频率将缓冲池中的数据刷新到磁盘中。这个刷新的频率根据配置进行选择，可以在每一次修改都刷新回磁盘，也可以等待一定的修改次数之后再刷新回磁盘。InnoDB内部设置了一个CheckPoint的机制来处理修改数据刷新到磁盘的机制（为了提高数据库的整体性能）

InnoDB存储引擎的数据库的缓冲池的大小设置，通过`innodb_buffer_pool_siez`设置，32下最多只能分配3G的内存，1G是内核空间使用，MySQL不能管理，64位可以设置的内存就很大了。

InnoDB还支持设置多个缓冲池实例，借此来减少数据库内部的资源竞争，增加并发下的处理能力；`innodb_buffer_pool_instances=2`，默认是1

![Mysql的InnoDB内存结构和磁盘结构](https://gitee.com/Jia_bao_Li/img/raw/master/img/InnoDB%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%92%8C%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84.png)

![img](https://gitee.com/Jia_bao_Li/img/raw/master/img/InnoDB%E7%BC%93%E5%86%B2%E6%B1%A0%E7%9A%84%E5%88%86%E7%B1%BB.png)



### 内存管理算法

（LRU List、Free List、Flush List）

数据库中的缓存池通过LRU算法来进行管理

InnoDB也是使用LRU算法（优化的）来进行管理的；缓冲池中的页大小默认是16KB

具体的优化：

- 将新读取到的页内存，不是直接放入LRU列表的首部，而是放置于LRU列表的midpoint（默认5/8）这个位置有参数`innodb_old_blocks_pct`控制，默认37（37%）也就是将数据页放到距离尾部37%的位置，63%的部分数据页都是热点数据页new部分，到尾部37%的部分是old部分

这样优化的原因：

- 防止某些SQL操作设计的内存页太多，而这一次操作的许多内存都只是使用很少的次数，如果直接放入到列表头，可能会更新删除掉许多的热点活跃数据
- 为了避免过多的热点数据被更新删除，`innodb_old_blocks_time`可以设置页读取到mid位置后，还需要多久会被更新到LRU列表的热点数据段
- old更新到new中是`page made young`过程，没有更新到new则是`pages not made young`

LRU需要更新内存页是当Free没有可用内存的时候才会进行的

查看缓冲池运行状态：

```sql
select POOL_ID,HIT_RATE,PAGES_MADE_YOUNG,PAGES_NOT_MADE_YOUNG
from infomation_schema.INNODB_BUFFER_POOL_STATS;
```

### 重做日志缓冲

redolog buffer：重做日志信息都会先放入到这个缓冲区，然后按照一定的频率刷新到重做日志文件中，一般这个缓冲设置的不大，默认InnoDB会1s的频率将重做日志刷新到日志文件中

这个缓冲区大小通过`innodb_log_buffer_size`控制，默认8MB

三种情况下，就会将缓冲区的内容刷新到日志文件：

- 每隔1s，主线程Master thread将该缓冲区刷新到日志文件
- 当事务提交时，将该缓冲区的日志刷回日志文件（事务提交时，缓冲区是否刷写通过配置项`innodb_flush_log_at_trx_commit=1`）
- 重做日志空间剩余小于1/2，也会将缓冲区刷新到日志文件中

### 额外的内存池

对一些数据结构的内存分配时，是从额外的内存池中进行申请，当这个区域内存不够会向缓冲池中申请

比如缓冲控制对象就需要从额外内存中申请

### CheckPoint技术

checkpoint是一个记录点，在这个记录点之前的内存页的数据都已经刷新回磁盘，因此数据库在宕机的时候不需要重做所有的日志，只需要对checkpoint之后记录下来的重做日志进行恢复即可，可以很好的缩短恢复的时间

checkpoint技术的目的：

- 缩短数据库恢复花费的时间
- 缓冲池不够用，将脏页刷新到磁盘中
- 重做日志不够用，刷新脏页

如果缓冲池不够用，会根据LRU算法进行溢出最近最少使用的内存页，如果这个被刷出的内存页是脏页，需要强制执行checkpoint，将脏页中的数据刷新回磁盘中。

InnoDB引擎，通过LSN（Log sequence number）来标记版本，重做日志、checkpoint和内存页中都有LSN，LSN是一个8字节的数字。`show engine innodb status`可以观察到LSN



## 后台线程

在InnoDB有四种后台线程：主要祖泽刷新内存池中的数据，保证缓存池中的内存缓存是最近的数据，将修改的数据文件刷新到磁盘文件中，保证数据库发生异常InnoDB可以恢复正常

- Master Thread：核心的后台线程，负责将缓冲池中的数据异步刷新到磁盘中，保证数据的一致性：脏页刷新、合并插入缓冲（Insert buffer）、undo页的回收
- IO Thread：使用AIO来异步处理IO请求，改善数据库性能。主要负责也不IO请求的回调处理
  - write thread：处理写IO的请求4个
  - read thread：处理读IO的请求。4个
  - insert buffer：处理插入数据的IO
  - log IO thread：处理日志文件的IO
- purge thread：事务提交后的Undolog不再需要，需要这个线程来回收undo占用的内存，用来分离出来减轻Master thread的工作压力的
- page cleaner thread：负责处理脏页刷新操作，也是为了减轻master线程的压力而抽离出来的，提高InnoDB引擎的性能

### Master thread工作

线程中的主循环中，有两部分操作，一个是每隔一秒的操作一个是每10s的操作：

每隔1s执行工作：

- 刷新日志缓冲数据到磁盘中，即使事务还未提交（总是）
- 合并插入缓冲（可能）需要判断前1s内IO次数，少于5次才会进行合并插入缓冲
- 最多刷新100个InnoDB的缓冲池中的脏页到磁盘（可能）判断缓冲池脏页比例是否超过阈值
- 如果当前没有用户活动，切换到后台循环backgroud loop（可能）

每隔10s执行的工作：

- 刷新100个脏页到磁盘（可能）判断过去10sIO操作是否少于200次，少于才执行
- 合并至多5个插入缓冲（总是）
- 将日志缓冲刷新到磁盘（总是）
- 删除无用的undo页（总是）
- 刷新100个（超过70%）或者10个脏页（小于70%）到磁盘（总是）

backgroud loop的操作：

- 删除无用的undo页（总是）
- 合并20个插入缓冲（总是）
- 调回主循环（总是）
- 不断刷新100个页到符合条件（可能，跳转到flush loop进行）



## 关键特性

- 插入缓冲
- 两次写
- 自适应哈希索引
- 异步IO
- 刷新邻接页

这些特性的查看都可以使用`show engine innodb status`来进行

### 插入缓冲

为什么引入插入缓冲？

- 解决非聚集索引（主键自增索引）插入的离散型带来的插入性能瓶颈

对于非聚集索引插入或更新操作，不是每次直接插入到索引页中，而是先判断插入的非聚集索引是否存在缓冲池中，若在直接插入，若不在，先放入一个insert buffer，然后再以一定的频率和情况进行insert buffer的辅助索引叶子节点的合并，往往就可以将多个插入合并到一个操作中，这就大大提高了非聚集索引的插入性能

insert buffer合并插入需要满足下列条件：

- 索引是辅助索引
- 索引不是唯一的：插入缓冲的时候，如果还需要判断唯一性的话，就需要查找索引页来判断记录唯一性，这就需要查找会出现离散读取，就失去了设置insert buffer的意义

但是插入缓冲在面对写密集的情况可能会导致一些性能问题，因为插入缓冲占据的缓冲池的内存最大可达1/2，占用过多会导致其他操作的性能带来影响



#### Change buffer

InnoDB在1.0.x版本开始引入，是insert buffer的改进升级版，对DML操作都可以进行缓冲，分别是Insert buffer、Delete buffer、Purge buffer

适用对象仍然是不唯一的辅助索引

### 两次写

两次写技术给引擎带来的是数据页的可靠性，插入缓冲带来的是性能的改善

### 自适应哈希索引

为了利用哈希索引的快速查找性能，InnoDB通过对表上各个索引页的查询情况，如果观察到建立哈希索引可以给查询带来速度的提升，就创建哈希索引，这种技术称为自适应哈希索引（Adaptive Hash Index，AHI）。

AHI通过缓冲池中的B+Tree的页来构造，建立的速度很快，不需要对整张表构建，InnoDB引擎自动根据访问频率和模式来自动为某些热点页创建哈希索引

默认开启这个特性。

### 异步IO

为了提高磁盘操作性能，数据库系统都是采用的异步IO方式处理磁盘操作。

异步IO：在发起一次IO操作之后，不需要等待IO操作完成，可以继续发起下一个IO请求，等全部IO发送完毕，就等待所有IO操作完成即可

同步IO：每一次发起一个IO操作，都需要等待IO操作完成并返回结果之后才进行下一个IO操作

AIO的优势：

- 可以不用等待IO请求完成，可以继续发送下面的IO请求，然后再去等待所有IO的完成
- 可以根据IO请求的情况决定IO请求内容，如果多次IO请求连续内存，它会将这几个IO合并为一次IO请求一个大内存。



### 刷新邻接页

刷新脏页的时候，InnoDB引擎会监测该页所在区的所有页，如果存在脏页，那么一起刷新。

- 是不是将不怎么脏的页刷新，之后该页又变脏页
- 固态硬盘效率提升了很多，是否还有必要使用这个



## 启动、关闭与恢复

### 关闭

参数`innodb_fast_shutdown`影响存储引擎为InnoDB时MySQL的关闭操作：

- 值为0：关闭时，InnoDB需要完成所有的fullpurge、merge insert buffer，并将所有的脏页都刷新回磁盘，可能需要花费一定时间。升级InnoDB需要将这个参数设置为0再进行升级
- 值为1：不需要完成full purge和merge insert buffer操作，将缓冲池中的数据脏页刷新回磁盘
- 值为2：不完成purge 和merge，也不刷新脏页，但是会写日志，不会丢失事务，但是下次 数据库启动会花费时间来进行恢复，可能耗费较长时间

### 恢复

`innodb_force_recovery`，设置了6个非零值，大数值包含小数的设置，为0标识会进行完整的回复操作。用户还可以自己选择回复，因此可以设置可以把握的恢复的选项

- 1：忽略检查到的corrupt页
- 2：组织主线程的运行，如果主线程需要进行full merge，会导致crash
- 3：不进行事务的回滚
- 4：不进行插入缓冲的合并操作
- 5：不查看undo log，InnoDB将为提交事务视为已提交
- 6：不进行redo log操作



## 索引

主键索引：InnoDB会根据下面的进行选择或者创建主键

- 首先判断表中是否存在非空的唯一索引，如果有，就选择这个索引作为主键索引。索引的选择按照索引创建的顺序（选取创建表时第一个定义的非空唯一索引）
- 如果没有非空的唯一索引，InnoDB会自动创建一个6字节大小的指针

一开始最好就清除是不是需要添加索引，当然索引的数量也不要设置的太多，设置的太多往往会导致性能下降

B-Tree索引：平衡多叉树，又平衡二叉树衍生的一种多叉树，拥有快速查找的特性，借助二分或者多分，可以快速定位到元素的位置。实际查找的时候，只能查找到包含数据行的数据页，然后通过再读取数据页快速定位到元素行的数据

全文索引：根据文本的关键字快速定位元素的一种索引类型

哈希索引：借助哈希函数快速将元素定位的一种索引类型。