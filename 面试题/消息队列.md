# 消息队列



消息队列的一些概念：

- 消息代理：消息发送者发送出消息之后，消息是由消息代理接管。消息代理保证消息传递到指定的目的地
- 目的地：也就是消息发送的接受者的位置

消息队列有两种形式的目的地：

- 队列：主要用于点对点消息通信，一对一
- 主题：发布订阅的消息通信，可以一对多

## 消息模型

点对点式：

- 消息发送者发送消息，消息代理将其放入到队列中，消息接受者从队列获取消息，消息读取之后移出队列
- 消息只有一个发送者

发布订阅方式：

- 发送方将发送消息到主题，对个接受者监听主题
- 消息到达的时候接受者就会接受到消息
- 可以有多个消费者

## 消息队列的协议

JMS：Java消息服务

- JVM消息代理的规范，ActiveMQ是JMS的具体实现

AMQP：高级消息队列协议

- 也是消息代理的规范，兼容JMS
- RabbitMQ是具体的实现

## 消息队列的使用场景

- 异步处理：比如用户注册账号这整个操作流程，分别有写入数据库、发送注册邮件、发送注册短信这三个操作，常规的处理流程是采用同步的方式来执行任务，但是实际上发送邮件和发送短信是两个互不影响的任务，可以采用异步的方式来减少任务执行时间。此外还可以使用消息队列，注册完成之后，只需要将发送邮件和短信的任务放入消息队列，之后再去由其他的执行器来执行这些任务即可。这样整体就给用户更好的体验。快递柜这一例子也可很好的解释异步调用。以前的快递员需要等客户取快递，有了快递柜之后，只需要短信通知客户快递到了，自己有空的时候取一下即可，快递员可以省下时间去干更多的事情
- 应用解耦：不同的系统之间相互调用，但是使用消息队列可以降低两个系统之间的耦合，使用消息队列的发布订阅，订单系统只需要将调用库存服务的请求写入消息队列，然后库存系统来取用这个消息并返回结果到订单系统
- 流量控制：秒杀业务场景，如果并发量太大，可以先不急于处理，而是将任务加入消息队列，后面再慢慢来处理这些任务

## 消息可靠性

### 发送端投递的可靠性

需要保证生产者完成消息生产之后，消息一定成功发送到队列里面

实现方法：通过发送确认机制来保证消息的可靠投递

Kafka中可以通过异常的捕获来确定是否成功投递消息，或者异步方式的话借助异步回调来进行判断（Kafka即使发送了ack也可能存在消息丢失，因为leader挂了的话消息还没有同步到其他的集群节点上，数据丢失，类似于redis的从节点懵逼上位的情况）

RabbitMQ中消息也是有可靠投递的，也是类似采取发送确认机制来确定。内部有两个回调方法，可以监听消息的是否成功发送，confirmCallback和returnCallback，前者是发送成功的回调，后者是消息发送失败的回调方法，因此使用者要确保消息可靠投递，需要在returnCallback里面设置消息重发的机制

```yml
#  rabbitmq的生产者的消息确认机制避免消息丢失
publisher-returns: true
publisher-confirm-type: correlated #新版本 publisher-confirms: true 已过时
```

### 消息存储服务的可靠性

消息在Broker端存储，如果是集群，消息会在该阶段被复制到其他副本。

正常情况下，只要Broker正常运行，就不会丢失消息。 但若Broker异常，比如进程卡死或服务器宕机，则可能丢失消息。

如果对消息可靠性要求非常高，可通过配置Broker参数避免因为宕机丢消息。

对单节点Broker，需配置Broker参数：在收消息后，将消息写进磁盘后再给Pro发确认响应，这即使宕机，也不会丢消息，恢复后还可继续消费。

因此消息队列的持久化一定要开启，避免存储在消息队列的消息因为某些状况导致的数据丢失

### 接受端消费的可靠性

保证消费者一定成功消费消息一次

具体实现：

- 接受端处理消息的过程保证幂等性，这样消费一次和多次产生的结果都是一样的，这样的话，消息队列对于出现问题的消息的处理只需无脑的重发即可，因为下游保证幂等的话就不会出现重复消费带来的问题
- 保证消息具有唯一编号，并且使用日志来记录消费的消息。
- 消息消费的确认最好在业务执行完之后再发送

对于重复消息，可以在业务端进行去重，去重的时候使用唯一性标识进行

在rabbitmq中，如果需要保证消息消费可靠性，需要开启消息的手动确认机制，而不是使用默认的自动确认机制（自动确认机制丢失消息的概率很大），也可以设置noack机制，不进行确认，因此消费之后消息依然会在队列中

At most once（最多一次，可能会丢失数据）

At least once（手动确认可以保证）

Exacly once（准确的一次消费，具体实现很困难）