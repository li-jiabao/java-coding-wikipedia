# 缓存穿透、缓存击穿和缓存雪崩

缓存是指利用redis 这一类数据库作为某些数据的暂存地址，利用key-value的存储方式进行保存。

当下一次碰见相同key的数据库请求时，可以直接将从redis中将数据返回给请求方，而不需要再请求数据库，这降低了数据库的访问次数，保护数据库的安全和稳定。

增加了缓存之后的数据库访问操作流程：

![image-20210913171832896](https://gitee.com/Jia_bao_Li/img/raw/master/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98%E6%B5%81%E7%A8%8B.png)



## 缓存穿透

> 指缓存中访问不到请求的数据，数据库中也访问不到请求数据

缓存穿透的原因：

- 自身业务代码出现问题或者数据出现问题
- 被非法攻击，爬虫的大量空命中

缓存穿透的危害：

- 如果有人使用大量的无效数据库请求访问数据库，增加了数据库的压力

缓存穿透的解决方案：

1. 业务层逻辑校验：验证数据库请求是否合法，这一实现需要在业务层判断sql语句请求是否可以访问到数据
2. 缓存空对象：把空请求的空结果缓存到redis，下一次出现这一类请求直接返回空，缓存空对象的问题：
   - 大量的空对象占据了过多的redis缓存，可以给这些空对象设置较短的过期时间，自动剔除
   - 还有就是缓存层和数据库层可能出现数据不一致的问题，可以利用消息系统或者其他方式清楚掉缓存层的空对象或者不一致的数据
3. 在redis和业务层设置布隆过滤器（数据变动不大，实时性低的数据）：因为布隆过滤器占用的空间较小，且判断数据是否存在某一个集合内的速度很快，可利用布隆过滤器在redis和业务层之间先做一层判断（布隆过滤器将存在的key先保存起来，之后用作判断，使用bitmap实现布隆过滤器），防止出现缓存穿透的这一类请求出现

| 缓存穿透的解决方案 | 适用场景                                     | 维护成本                                                     |
| ------------------ | -------------------------------------------- | ------------------------------------------------------------ |
| 缓存空对象         | - 数据命中不高<br />- 数据频繁变化，实时性高 | 代码维护简单、需要较多的缓存空间<br />会出现数据不一致的 情况 |
| 布隆过滤器         | - 数据命中不高<br />数据变化不频繁，实时性低 | 代码维护发杂、缓存空间占用少                                 |
|                    |                                              |                                                              |

## 缓存击穿

> 指缓存中没有数据，数据库中有。往往是因为缓存中的某个或者某几个热点key失效过期

缓存击穿的原因：

- 缓存中的key过期，之后立马出现高并发请求请求该缓存中失效的key
- 这大量的请求都堆积到数据库，后端负载加大，可能导致系统崩溃

缓存击穿的危害：

- 导致数据库压力暴增，负载突然增加
- 严重的可能会导致系统崩溃

缓存击穿的解决方案：

1. 设置热点数据永不过期：将那些经常被请求的数据的key设置不过期或者过期时间较长

![image-20210913175619075](https://gitee.com/Jia_bao_Li/img/raw/master/img/%E7%BC%93%E5%AD%98%E4%B8%8D%E8%BF%87%E6%9C%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%B5%81%E7%A8%8B.png)

2. 分布式互斥锁：保证每个key同时只有一个线程去查询后端服务，这个时候其他的线程没有获取分布式锁的权限，等待线程更新缓存之后再访问缓存获取数据。这种方式将压力转到分布式锁，分布式锁的设计就很重要

![image-20210913174749982](https://gitee.com/Jia_bao_Li/img/raw/master/img/%E7%BC%93%E5%AD%98%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png)



两种缓存击穿的解决方案对比：

| 缓存击穿解决方案 | 使用场景                                     | 优缺点                                                       |
| ---------------- | -------------------------------------------- | ------------------------------------------------------------ |
| 分布式锁         | 数据库访问和更新缓存时间较短的时候           | 将数据库压力转到分布式锁设计上，降低了数据库的压力<br />数据一致性比较好<br />如果查询数据库和重建缓存时间过长，导致高并发场景的吞吐量大大降低<br />还可能出现死锁和线程池阻塞 |
| 热点数据不过期   | 高并发要求高，且热点数据很明显，热点数据不多 | 不会再出现热点数据过期导致的缓存击穿问题出现<br />存在数据不一致的情况<br />同时代码复杂度较高 |



## 缓存雪崩

> 缓存层出现问题或者停止服务时，导致大量的请求涌向数据库，导致数据库的崩溃，或者缓存中的大量热点数据失效过期，导致大量高并发请求涌入数据库

缓存雪崩的原因：

- 缓存层死机停止服务
- 缓存层出现问题导致缓存功能失效

缓存雪崩的危害：

- 后端存储层的崩溃，服务器的宕机等

缓存雪崩的解决方案：

1. 缓存设计成**高可用**：即使个别机器、个别节点或者机房宕机，依然可以很好的提供缓存服务（cluster或sentinel实现）
2. 采用多级缓存：本地进程作为一级缓存，redis作为二级缓存，不同级别的缓存设置的超时时间不一样，即使某个缓存失效，还有其他缓存兜底
3. 缓存的过期时间使用随机值，尽量让不同的key过期时间不同

## 布隆过滤器

