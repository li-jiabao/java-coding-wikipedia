# 1 分布式事务

## 1.2 分布式理论

### CAP定理

在一个分布式系统中，下面的三大特性是没有办法同时满足的：

- 一致性：在分布式系统中的所有数据备份，在同一时刻是否拥有相同的值，也就是所有的数据副本内容是否一致
- 可用性：在集群中一部分的节点故障后，整个集群是否还能够正常提供请求，响应客户端
- 分区容错性：出现某个组件或者服务的不可用，操作依然可以完成

上面的三大特性在分布式系统中，任何的数据库设计都只能保证在应用中同时支持上面的两个属性。

但是分区容错性很重要，基本是必须要保证的内容，因此设计的时候只能在一致性和可用性上面取舍

### BASE理论

分布式系统中，往往更追求的是可用性，重要程度比一致性的要高。那么实现高可用性的具体应该如何去做？

前任提出的一个理论是用来解决可用性的。BASE，是在CAP基础上扩充的：

- Basically avaliable基本可用
- Soft state软状态
- Eventually consistent：最终一致性

就是在分布式系统设计中无法实现强一致，但是再具体的业务实现中，可以采用一定的手段和针对性色剂，让系统可以达到最终一致性



## 1.3 分布式事务解决方案

### 两阶段提交

MySQL的事务就是通过日志系统实现两阶段提交。

两阶段提交的重点就是设置一个全局的事务管理器来协调各个子系统的局部事务管理器完成两阶段提交。

![image-20211228232510350](https://gitee.com/Jia_bao_Li/img/raw/master/img/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5.png)

第一阶段流程：

- 协调者A向子系统的参与者发起命令告知需要进行某个操作
- 参与者根据自身的状态告知协调者是否可以参与此次提交
- 协调者收集并汇总所有信息

![image-20211228232537642](https://gitee.com/Jia_bao_Li/img/raw/master/img/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5.png)

第二阶段流程：

- 协调者根据所有参与者发送的信息判断是否都可以进行提交
- 如果都可进行提交，那么就会发起提交命令，否则直接抛弃该命令
- 参与者收到协调者发送的命令并执行
- 执行的结果返回给协调者

两阶段提交存在的问题：

- 单点故障：如果事务管理器也就是协调者出现问题，整个系统故障
- 数据不一致：如果事务管理器只成功发送部分命令或者部分参与者没有收到命令，导致某些命令没有执行成功，会导致整个系统存在数据不一致
- 响应时间长：整个消息串行，需要等待响应结果，不适合高并发
- 不确定性：由于存在commit提交的任务不一定全部成功执行，且如果任务管理器和执行成功的参与者都宕机，后面选举的事务管理器不能确定消息是否成功提交

### 三阶段提交3PC

相比两阶段提交，增加了一个CanCommit确认阶段（确认参与制是否能够执行命令）和超时机制（如果没有收到协调者的消息，超时自动进行commit，解决了单点故障问题）

- 第一阶段：向参与者发送确认消息Cancommit，确定参与者能够参与此次提交
- 第二阶段：向所有参与者发送precommit指令，参与者收到之后开始执行事务，并将undo和redo日志记录下来。参与者执行完毕之后向协调者发送ack告知准备好
- 第三阶段：收到了全部的参与者的ack之后发起Docommit操作，然后进行事务的提交。参与者都进行事务的执行提交，如果有一个没有执行完毕，协调者会向所有的参与者发起abort请求撤销中断事务

特点：

- 只是解决了2PC的单点故障问题
- 性能和不一致还是没有解决

### 补偿事务TCC

采用了补偿机制，核心：针对每一个操作都注册一个对应的确认和补偿（撤销）操作，分为三个阶段：

- Try尝试阶段：主要对业务系统进行监测和资源的保留
- confirm：对业务系统做确认提交，try执行成功后执行confirm，只要try执行，confirm一定成功
- cancel：业务执行错误，需要回滚时执行的业务取消，资源释放等

类似于错误的捕获处理，没报错就完整执行，一旦某个操作报错直接结束并执行异常捕获的逻辑进行回滚操作

TCC的特点：

- 解决了协调者的单点
- 同步阻塞
- 数据一致性
- 代码复杂度增加，不能复用

### 本地消息表

本地消息表的思路：在本地添加一个消息表（消息队列）。

消息的生产方，需要额外建立一个消息表，并且记录消息的发送状态。消息表和业务数据要在一个事务中提交，消息再由消息队列发送给消息的消费方。消息发送失败会进行失败重试。<font color='red'>写本地消息和事务执行需要保证原子操作，因此一般放在事务中执行</font>

消息消费方，需要处理接受到的消息，根据消息的指示进行业务逻辑的处理。处理成功表明消息成功消费，否则进行重试执行。如果业务失败，向生产者发送一个业务补偿消息，生产方进行失败的补偿机制处理

不管是生产者还是消费者都是需要定期扫描本地消息表，处理还没有消费的消息并重发发送失败的消息

这种方式遵循了BASE理论的最终一致性。由于消息表的存在可用性可能存在一定的问题，此外业务上的设计需要处理更多的内容

### 消息事务

利用消息中间件进行异步解耦。

同本地消息表一样还是需要依赖MQ来实现分布式事务，基本步骤如下

1. 系统A发送prepare消息到MQ
2. 收到ack执行本地事务，并根据执行结果发送消息，MQ根据执行结果判断是否将prepare消息转为confirm消息
3. 对于迟迟不发送本地事务执行结果的prepare消息，MQ会进行回查
4. 系统B消费MQ中的消息

RockerMQ支持事务消息，kafka和RabbitMQ不支持。

阿里的RockerMQ的思路：

- 第一阶段准备消息，拿到消息的地址
- 第二阶段执行本地事务
- 第三阶段通过第一阶段拿到的地址访问消息修改状态

![image-20211230152327061](https://gitee.com/Jia_bao_Li/img/raw/master/img/%E6%B6%88%E6%81%AF%E4%BA%8B%E5%8A%A1.png)

优点：

- 实现了最终一致性，不依赖本地数据库事务

缺点：

- 实现较难，主流MQ不支持

### 最大努力通知

发送通知方尽自己最大努力将业务处理结果通知到接受方：

最大努力通知，发起通知方尽最大的努力将业务处理结果通知为接收通知方，但是可能消息接收不到，此时需要接收通知方主动调用发起通知方的接口查询业务处理结果，通知的可靠性关键在接收通知方。

适用于一些时间敏感度比较低或者分布式事务要求不太严格的业务。

1. 系统A执行本地事务之后，发送消息到MQ
2. 系统B消费MQ，系统B执行失败会进行重试。

### Segas事务模型

又称为长时间运行的事务

核心：

拆分分布式系统的长事务为多个短事务，或者说本地事务，然后一个Segas工作引擎负责协调，如果整个流程正常结束，就算事务业务成功执行，如果过程中出现失败，就进行相反顺序的补偿操作调用进行业务回滚

